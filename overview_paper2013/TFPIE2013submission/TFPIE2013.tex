\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TFPIE 2013} % Name of the event you are submitting to
\usepackage{url}
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{color}

\newcommand{\allcomments}[1]{{#1}}
%\newcommand{\allcomments}[1]{}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{StephensBlue}{RGB}{0,204,204}
\definecolor{JoesGold}{RGB}{204,102,0}
% Uncomment this if you don't want to show comments
\newcommand{\elenacomment}[1]{{\bf \textcolor{ForestGreen}{\allcomments{{#1}}}}}
\newcommand{\stephencomment}[1]{{\bf \color{StephensBlue}{\allcomments{{#1}}}}} %%%  or pick your color
\newcommand{\joecomment}[1]{{\bf \color{JoesGold}{\allcomments{{#1}}}}}
\newcommand{\todo}[1]{{\bf \color{magenta}{\allcomments{ To-do: {#1}}}}}
% \renewcommand{\elenacomment}[1]{}

\newcommand{\clocode}[1]{{\tt {#1}}}


\title{Steps towards teaching the Clojure programming language in an introductory CS  class.}
\author{Elena Machkasova 
\institute{University of Minnesota, Morris
\email{elenam@morris.umn.edu}}
\and
Stephen J Adams 
\institute{\email{adams601@morris.umn.edu}}
\and 
Joe Einertson 
\institute{University of Minnesota, Morris
\email{eine0017@morris.umn.edu}}
}
\def\titlerunning{Teaching Clojure}
\def\authorrunning{E. Machkasova, S.J. Adams \& J. Einertson}
\begin{document}
\maketitle

\begin{abstract}
The Clojure programming language is a new language in the LISP family that is gaining rapid popularity in industry due to its elegant design and suitability for concurrent programming. We argue that Clojure has benefits for being taught as a programming language in an introductory course. We discuss several challenges that need to be overcome in order to teach Clojure to students with no programming experience, such as modifying error messages and providing a beginner-friendly development environment, and describe our work in progress towards these goals. We also discuss conceptual approaches towards teaching Clojure to beginners that make use of Clojure sequence abstraction. 
\end{abstract}

\section{Introduction}
%\joecomment{Any particular reason I'm listed as Joseph rather than Joe? Either one is fine but Joe is what I usually go by/is most Googleable}
%\joecomment{Typo in the title. Pick either 'of' or 'to' in the beginning.}
The Clojure programming language is a new language in the LISP family that is gaining rapid popularity in industry due to its elegant design and suitability for concurrent programming. Clojure is beginning to be incorporated into upper-division undergraduate courses, including those at University of Minnesota, Morris (UMM). In this paper we argue that there are educational benefits in using Clojure as a programming language in an introductory course (section~\ref{sec:benefits}). We discuss several challenges that need to be overcome in order to teach Clojure to students with no programming experience, such as modifying error messages and providing a beginner-friendly development environment. We describe our efforts towards these goals (section~\ref{sec:technical}). We also discuss conceptual approaches towards teaching Clojure to beginners that make use of Clojure sequence abstraction (section~\ref{sec:approaches}). 

The project on adopting Clojure as a language for an introductory class is work in progress conducted at UMM as a combined effort of faculty, students, and alumni. Currently we are implementing and improving beginner-friendly Clojure development environment. 
%and utilizing testing feedback from two sophomores (computer science majors) who have no prior experience with Clojure, and one of whom has no experience with functional programming. 
The introductory level class that uses Clojure is planned for the Fall semester of 2014. 

%\todo{Mention the state of work in progress}
%\begin{itemize}
%\item Why we chose Clojure
%\item Challenges  that Clojure poses for adoption in introductory material
%\item How we are dealing with these challenges
%\item Who is working on this, mention testers here I think\elenacomment{Who wrote this?} \stephencomment{Me} \elenacomment{Moved from later: (our testing group includes two sophomores with no prior experience with Clojure)}
%\item\elenacomment{The state of the project}
%\end{itemize}


\section{Overview and history of Clojure}
Clojure is a dialect of Lisp developed by Rich Hickey and released in 2007~\cite{Hickey:2008}. Clojure was developed to answer the need for a practical  functional language that supports convenient, efficient, and safe programming for concurrency. Clojure provides a rich set of immutable data structures, augmented with several kinds of mutable reference types. Clojure in its classical implementation is complied into Java bytecode and can be fully integrated with Java, both by using Java objects and methods and by providing code that can be invoked from Java. It also provides a REPL (Read Eval Print Loop) %that allows 
for interactive development.

Clojure was carefully designed with efficiency in mind, and provides constructs for tail call optimization,
%(at compilation time, due to Java's lack of support of tail call optimizations) 
%\joecomment{Is this comment necessary? doesn't really relate to the topic of the paper}\elenacomment{people who knwo that Java doesn't do TCO may be surprised otherwise, but fair enough, we need to cut something.}
data structures with fast traversal to any element that maximize sharing when a modified version is created, and efficient handling of lazy structures, among other mechanisms for providing efficiency. As a result, Clojure is as fast as Java on their shared underlying platform (the JVM). It is also much more effective 
for concurrent execution due to immutability of data structures and a significantly reduced need for locking and synchronization. 

Because of its convenience, efficiency, and elegant design 
Clojure is rapidly gaining popularity in the software development community. In 2012 Clojure was rated as "Adopt" by the ThoughtWorks Technology Radar; there were four major industry conferences dedicated to Clojure, two in the US and two in Europe, and the blog aggregator "Planet Clojure" includes over 400 blogs.%~\cite{clojure:review}. 

\section{Benefits of teaching Clojure as the first language}\label{sec:benefits}
%\subsection{Overview of an introductory CS course and its role in CS curriculum}
%\joecomment{Capitalizing computer science feels (is) incorrect. Also, I don't know what the distribution of this paper will be, but college has a very different connotation (trade school/community college) in most of the rest of the world. I would use university instead.} 
In this work we explore incorporating Clojure into an introductory undergraduate computer science course. We describe the course setup at UMM which is fairly typical for a small university. At UMM we have about 3.5 contact hours per week that include lecture and lab time and other activities, e.g. group discussions. There are 30-40 students in the course, including CS majors/minors, undecided students with  interest in CS, and those taking it to satisfy an elective or a general education course. The majority of the students (even those who intend to major in CS)  have no prior programming experience and very little understanding of the process of computing. 
%\stephencomment{This paragraph seems unnecessarily generic especially since the next two paragraphs talk fairly specifically about our program with very "concrete" language. I think we can reword it to talk more specifically about Morris's program or at least in the 1st person plural. Rather than saying "Such a course has" we could say "We have about 3.5 contact hours" thoughts?}\elenacomment{I suppose. I am not entirely sure how this is typically written. I can rephrase it}

The course focuses on problem solving in general and  its applications to computer science.
%\stephencomment{"The course focuses on general problem solving and the specifics of implementing solutions in a programming language."?? I feel like the second half of this sentence should be a little less vague.}.
%\elenacomment{I don't think it's just a programming language connection. I meant generally the way computers operate. So I'd argue for my wording.}
%\joecomment{I also didn't like this section, but I agree with Elena's point. How about "the course focuses on both general and computer science-specific problem solving?"}
Students work on understanding a problem's requirements and gradually develop solutions in a programming language, with an emphasis on effective design and testing strategies. They learn about language syntax and behavior, key programming concepts such as conditionals and functions, data representation in a program, and similar introductory-level concepts. Mastering the concept of recursion is one of the key learning objectives in the course since it is a basis of many important data structures and algorithms. 
%\stephencomment{Perhaps expand on why we value recursion?}. 
Towards the end of the course students develop their own implementations of simple searching and sorting algorithms and are informally introduced to the notion of big-O. Course exercises include both concrete assignments and open-ended projects, such as graphics and simple game development. Students often work in groups, which promotes inter-personal communication and a code style that conveys intention. 
\elenacomment{We used to have a paragraph here about the place of 1301 in our curriculum, and it's likely that we want it back}

%Students continuing in the CS program would take 
%%a version of a discrete mathematics class as their second CS  course and 
%Data Structures (in Java) as their next programing course. The rest of our curriculum incorporates a variety of languages and systems, but assumes solid understanding of Java by all students. 
%It is important to note that not all students in subsequent CS courses have come from this introductory course: at UMM, for instance, we have an alternative entry point for the CS major that explores the same introductory concepts using digital media (images, music, etc.) and the Python programming language, to better accommodate students who approach CS from the design and artistic standpoints. \elenacomment{while this is important from the practical standpoint, I am not sure we have room for this here} \stephencomment{Doesn't seem super necessary from this paper's perspective.}

%\todo{A bit about assumed setup of CS curriculum; learning goals}

%\subsection{Benefits of teaching Clojure in an introductory class}
The benefits of using a functional programming language in introductory computer science classes are well-known~\cite{thomsonEducation}. Functional languages focus on functions as programming units, provide abstraction, generalization, and modularity, and give a better understanding of recursion, one of the key learning goals in an introductory course. 
%\elenacomment{I moved explanation of why recursion is important to the earlier section}
Functional languages tend to have simpler, more uniform syntax that students master quickly. There are several successful introductory functional languages curricula, such as the How To Design Programs course with %a Lisp dialect
 Racket~\cite{htdp} and introductory courses with Haskell, e.g.~\cite{haskell}.

%\elenacomment{reference Racket, Haskell, ML?}\stephencomment{I think Racket definitely should be mentioned here. Not so sure about the other two. I know that Harvard uses a little ML, but Kent is the first school that I've heard of using Haskell for their intro classes and they are switching to Erlang next year.}\elenacomment{My colleagues in Frankfurt teach Haskell. I think it's fairly common in Europe. Less sure about ML, I don't know of anyone who teaches it as the first language} \stephencomment{Harvard seem to be using OCaml in their second CS course for majors (CS51) which seems to be a lot about OO programming. Either way they are the only school I've heard of using it but since it's Harvard there are sure to be imitators. It seems that Racket and Haskell should be mentioned, ML maybe not as much.}

Developing a similar undergraduate curriculum based on Clojure would provide additional benefits. 
%Clojure is a language that was 
%developed for real-life software development \stephencomment{"developed for use in industry" or "
%\joecomment{I like Stephen's other suggestion of "for use in industry" better. Industrial software development parses ambiguously (we are not talking about a factory which generates code)}
%developed for use in industry \stephencomment{This seems out of place here and unnecessary}. 
Clojure combines a rich set of features %(including a variety of mechanisms for concurrency) 
with an elegant uniform underlying model based on abstraction. Clojure ``collections'' (i.e. data structures) include lists, vectors, sets, and hashmaps. However, 
%all of them can be worked with as sequences \stephencomment{"
all of these collections can be worked with as sequences (see section~\ref{sec:approaches}). 
%While it would be impossible (and unnecessary) to present all of Clojure's features in an undergraduate course, 
Abstraction-based language model teaches students to use and appreciate abstraction and modularity
% in their own solutions. 
and  makes it easier for students to learn language features and libraries not covered in class on their own. 
%Understanding the underlying abstractions and concepts makes it easier for students to build upon what they learn in the class.
%%\stephencomment{End sentence here} and learn on their own. 
%The underlying abstractions also teach students about a good language design and problem solving that focuses on the essence of the problem and not on specifics of a given structure. \elenacomment{talk about focus on abstraction}

%\elenacomment{Make it clear that these benefits are as students move forward}
Clojure is also beneficial in preparing students for moving forward in the CS program. 
Clojure is fully integrated with Java since both compile to Java bytecode: Java code can be called from Clojure and vice versa.
%, and Clojure code can be called from Java  \joecomment{and vice versa?}. 
Integration with Java does not have an efficiency penalty for either of the languages. 
%It is important to keep in mind that Clojure integrates with Java without losing efficiency, and Clojure itself is as efficient as Java and does not impede Java optimizations. 
%As students continue in the CS curriculum\stephencomment{??} \elenacomment{better (changed the rest of the sentence slightly as well)? This may address your later question as well}, 
Students can  integrate Clojure into projects developed in Java or labs that use pre-written Java code in their upper-division classes, allowing them to incorporate functional style of programming as needed, even in a part of a project. 
%This gives students a choice of languages and paradigms 
%that can be made by a student or a group individually \joecomment{everything from "that can..." is redundant: "This gives students a choice...that can be made by a student"}, 
%without need for uniformity with the rest of the class or the rest of the project.\stephencomment{I think this paragraph needs to clarify what Java interop accomplishes for intro students. I'm not seeing how this would be successfully incorporated into 1301 from what you say here.} \elenacomment{I don't think intro students will be using Java interop. Not sure what you mean.} \stephencomment{We are in the "Benefits of teaching Clojure in an introductory class" subsection and started talking about Java interop so I got a little confused when intro students would be using these features. If we want to mention how our curriculum leads into Java code and that introducing Clojure in our intro class can ease the transition into Java.}

A related benefit is Clojure's suitability for concurrency. Clojure provides mechanisms for multithreading that do not require explicit thread synchronization,  locks, 
%objects \joecomment{object locking? Locking objects sounds like a weird euphemism for safes or keys or something}, 
or adjustments to the number of processors. The simplest forms of Clojure multithreading, e.g. a function \clocode{pmap}, which stands for {\it parallel map}, can be mentioned and used in an introductory class. However, explaining principles of parallel execution is beyond the scope of an introductory class. Despite this, background in Clojure would make it easier for students to learn this material in a later course or independently.% for a project or an internship.
% or, if need be \joecomment{I think this interjection is unnecessary.}, independently for a project or an internship. 
%\joecomment{My previous comment may have been unclear - I meant you should only remove the "if need be." I think there is value in mentioning the independent/internship part.}
The students would already be familiar with key concepts, such as immutable persistent data structures. Clojure is a good fit for the recent 
emphasis on teaching concurrency in undergraduate curriculum (e.g.~\cite{Brown:2010}). 

Clojure has a friendly, well-developed
%\elenacomment{added "friendly" - thoughts?} \stephencomment{I haven't had any problems with people and I'm sure conference attendees will know that this is an issue with several FP communities.} \joecomment{Swapped word order so sentence flows better.}
community with online users-maintained 
%\joecomment{Don't like the double "community" here. Is there a different way to say "community-maintained"?} 
documentation and examples, multiple blogs, several Google groups and an IRC channel, numerous open-source projects, and several excellent quality books (although not at a beginning programmer level). All these resources would enable students to continue their Clojure development past the introductory course. 
%\stephencomment{I feel like the biggest issue with this subsection is that it is supposed to be about what Clojure has to offer introductory students. However a large section of it is about two fairly advanced features (interop, and concurrency) that don't seem to be useful to an introductory student. If you are trying to talk about these advanced features as helpful for transitioning intro students into higher level classes I think that needs to be more explicit.}\elenacomment{Good point. Will change.}
%\joecomment{This section feels a little disorganized in places, but makes many good points. I would try to improve the flow by leading from each paragraph/point into the next.}

%\todo{Benefits of teaching Clojure to undergrads: provides all the benefits of teaching functional first, integrates with Java,  is used in industry and becoming quite popular (availability of examples), is done right, is a great language to program for oneself, introduces parallel computation}

\section{Technical challenges of teaching Clojure as the first language}\label{sec:technical}
The key technical (as opposed to conceptual) challenges of teaching Clojure to beginners stem from the fact that it was not designed as a language for beginners. Clojure currently does not have a beginner-friendly development environment. Another significant problem is that Clojure error messages come directly from Java and mention Java types and other notions %(such as null pointer exceptions) 
that do not appear directly in Clojure (Clojure is implicitly typed) and are not understandable to beginners. 
%There are a few common functions with names that may be misleading to new students. 
Below we describe our work developing a custom environment that addresses these problems.

\subsection{Customizing Clojure error messages}\label{subsec:errors}

Clojure error messages are Java exceptions and therefore refer to Java types (some native to Java and some coming from Clojure's implementation in Java) that are unclear to beginners, especially because Clojure is dynamically typed with no need  to specify types explicitly. 
%, and as a beginner you never have to specify any types explicitly \joecomment{This last part should be clarified. It reads like all beginners are magically exempt from explicit typing}. 
Types used in Clojure implementation form a rich Java hierarchy; for instance, numerous types implement an interface that represents a Clojure sequence type, with subtle differences in internal representations.   
These nuances do not matter to students, but would get in the way of their learning experience. There are also cases when an error message does not make sense to new students at all, such as {\tt NullPointerException}: students do not understand a concept of a pointer, and understanding it would require background  not only in Clojure, but also in the underlying Java. 
%\stephencomment{awk} \elenacomment{I'll think about phrasing here} \joecomment{A semicolon rather than parenthetical phrase would make this read less confusingly.}. 

Our run-time environment runs student code in a \clocode{try/catch} block which allows us to catch and customize error messages. 
We use two approaches to improving Clojure error messages for beginners:
\begin{itemize}
\item for frequently used functions, such as \clocode{map, reduce, filter}, we provide \clocode{preconditions}  to detect parameters that are of the wrong type. This allows us to detect and report more precise information about errors than is contained in a default error message. 
\item for all other errors we rewrite an error message to use more beginner-friendly terminology. 
\end{itemize}

\subsubsection{Using preconditions for commonly used functions}\label{subsub:pre-cond}
One of the learning goals in a functionally-focused introductory CS course is mastering abstraction and modularity by using higher-order functions. For example, we expect students to use a predefined function \clocode{map} to apply an operation to every element of a sequence to obtain a new sequence. For instance, \clocode{(map inc '(1 2 3))} applies a function \clocode{inc} (stands for ``increment'') to a sequence \clocode{(1 2 3)}, to produce a sequence \clocode{(2 3 4)}. However, \clocode{map} can be used only when the first argument is a function and the second argument is a sequence\footnote{or a data structure that can be converted to a sequence, such as a string or a set. See Section~\ref{sec:approaches} for a more detailed discussion of Clojure sequences.}. When a wrong type of an argument is passed to the function, the default error messages are not beginner-friendly:
\clocode{(map inc 4)} results in the error message

{\tt
java.lang.IllegalArgumentException: Don't know how to create ISeq from: 

java.lang.Long
}

\noindent
and \clocode{(map 5 '(1 2 3))} produces the error message

{\tt 
ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  
}

Not only do these error messages mention Java classes and interfaces that students are not familiar with, such as {\tt ISeq} which is an interface for Clojure sequences, or {\tt java.lang.Long} which is the default representation of an integer number, but also they fail to indicate which argument to \clocode{map} is causing the error. 

Our approach to handling this situation is to provide preconditions that check that the first argument is a function and the second one is a sequence. If all the preconditions are satisfied, the predefined function \clocode{map} is called with the given arguments. If any of the conditions is violated, information about the argument is recorded and incorporated into the error message. The error message for \clocode{(map inc 4)} then becomes

{\tt 
Second argument 4 must be a sequence but is a number
}

\noindent 
and the one for \clocode{(map 5 '(1 2 3))} is 

{\tt
First argument 5 must be a function but is a number
}

The function \clocode{map} in Clojure is more general than the above examples indicates: it may take any number of arguments. The first argument must be a function, and the rest of the arguments are sequences. \clocode{map} produces a sequence whose first element is the result of applying the function to the first elements of all sequences, the second element is the result of applying it to the second elements, and so on. For instance, \clocode{(map + '(1 2 3) '(1 2 3))} results in the sequence {(2 4 6)}.
Thus a well-formed call to {\tt map} may have more than two arguments. Our precondition approach allows us to detect which argument is causing the problem. For instance, {(map + '(1 2 3) :a)} results in an error message

{\tt
 Third argument :a must be a sequence but is a keyword
}

Functions that take an arbitrary number of arguments are quite common in Clojure. Some of them require a very careful analysis because some arguments are optional. As an example, consider Clojure function \clocode{reduce} which takes a function and a sequence and produces a value by applying the function to combine each element of the sequence with the result being accumulated. For instance, \clocode{(reduce + '(1 2 3))} results in $6$. The analog of \clocode{reduce} in Lisp is \clocode{foldl}. 

It is possible to pass a starting value of the result  (a  ``seed'' ) to \clocode{reduce} as the second argument.  For instance, \clocode{(reduce 4 '(1 2 3))} results in $10$ since $4$ is used as the starting point of the result, and the rest of the elements are added to it. The precondition for \clocode{reduce} then becomes: the first argument must be a function, and if the total number of arguments is two then the second argument must be a sequence, otherwise the third one must be a sequence. Our error messages for \clocode{reduce} handle these situations as follows: 

\clocode{(reduce 4 [1 2 5])} results in the error message

{\tt
First argument 4 must be a function but is a number
}

\clocode{(reduce + inc)} has two arguments, and therefore the condition is checking that the second one is a sequence. The resulting error message is:

{\tt
Second argument inc must be a sequence but is a function
}

In the case of \clocode{(reduce + 2 5)} the second argument is a seed, and therefore there are no conditions for it. The third, and last, argument must be a sequence, as the error message indicates:

{\tt
 Third argument 5 must be a sequence but is a number
}

The advantages of using preconditions include the ability to record the arguments that failed the condition and a high degree of customization for both the conditions and the error messages. Error messages generated with the preconditions report the ``offending'' argument's position, value, expected type, and observed type. 

The disadvantages include the need to write preconditions for each function individually and the extreme care that must be taken to make sure that they are accurate in all circumstances. A precondition that is too strict may disallow a valid use of a function. Another potential disadvantage is that user-defined functions would have somewhat different error messages than the predefined ones. For instance, if a student were to write their own version of \clocode{map}, they would not be getting the same style error messages than the ones the preconditions are providing in the same situation. Finally, if evaluating an argument results in a side effect and the preconditions are satisfied, the side-effect would take place twice: once for checking the precondition, and the second time for calling the function. While this is not a problem in a purely functional computation, an evaluation of a function with side effects (such as graphics) may be unexpected. Interactions of this potential issue with Clojure laziness is a subject of future investigation. One should note, however, that there is always an option of calling the original Clojure functions directly, bypassing the preconditions. Error messages in this case will be generated using techniques covered in Section~\ref{subsub:rewrite}. 

Note that our customized functions with preconditions have the same names as Clojure predefined functions, so they ``overshadow'' these functions. If one would like to call an original Clojure function, such as {\tt map}, a fully qualified name would be required: \clocode{clojure.core/map}. An alternative approach would be to create our versions of predefined functions that follow a naming convention, for instance \clocode{bmap} for a ``beginner map''. The reason we decided to use the same names as core Clojure functions is to simplify access to many online examples that use predefined functions, and, even more importantly, to make it easier for advanced students to transition to ``real'' Clojure for open source projects or other community shared code if they are use the same names as the core Clojure. The beginner-friendly functions would be provided to students in a transparent and flexible way: the source will be fully available and students would be able to switch to between the original predefined functions and the beginner-friendly ones,  so that they can choose a setup that works for the purposes of their project at any given point. 

%The list of functions that we provide preconditions for, as well as the exact preconditions, are still work in progress. 


\subsubsection{Rewriting Clojure error messages}\label{subsub:rewrite}

%\subsection{Error messages}\label{subsec:errors}
\begin{table}[t]
\centering
\begin{tabular}{|c|c|}
\hline
Original type & Beginner-friendly type \\
\hline
java.lang.Number & a number \\
java.lang.Integer & a number \\
java.lang.Double  & a number \\
clojure.lang.BigInt  & a number \\
%java.lang.Float & a number \\
java.lang.String & a string \\
java.lang.Character & a character \\
%clojure.lang.Symbol  & a symbol \\
clojure.lang.ISeq & a sequence \\
clojure.lang.Ref  & a mutable object \\
\hline
\end{tabular}
\caption{Sample type conversion}\label{table:types}
\end{table}
\begin{table}
\begin{tabular}{|c|c|c|}
\hline
Exception type & Original message & Beginner-friendly message \\
\hline 
{\tt ClassCastException} & $X$ cannot be cast to $Y$ & {\parbox{5cm}{Attempted to use $X'$, \\ 
but $Y'$ was expected.}} \\[0.3cm]
\hline
{\tt IllegalArgumentException} & 
Don't know how to create $X$ from:  $Y$ & 
{\parbox{5cm}{Don't know how to \\ create  $X'$ from $Y'$}} \\[0.3cm]
\hline
%{\tt IndexOutOfBoundsException} & $n$ & {\parbox{5cm}{An index in a sequence \\ 
%is out of bounds. The index is: $n$}} \\[0.3cm]
{\tt IllegalArgumentException} & F not supported on type: X &
{\parbox{5cm}{Function F' does not allow X' 
\\ as an argument}} \\[0.3cm]
\hline
{\tt NullPointerException} & -- &  {\parbox{5cm}{An attempt to access a 
\\ non-existing object
\\ (NullPointerException)}} \\[0.3cm]
\hline
\end{tabular}
\caption{Sample message wording conversion. $X,Y$ are the original types, $X',Y'$ are the corresponding beginner-friendly types, $F$ is a function name, $F'$ is a simplified function name (without any qualifiers)}\label{table:messages}
\end{table}

%\elenacomment{Update tables to new messages}


%\elenacomment{mention earlier that we are developing an environment}

While preconditions are helpful for commonly used functions, it would not be feasible (or necessary) to provide them for all predefined Clojure functions. Besides, students will be writing their own functions (including anonymous functions) for which no preconditions are defined. Thus we need to provide a way to transform native Clojure messages into beginner-friendly analogs. 

There are also cases when simple type checking that can be done in a precondition is not sufficient. For example, even if we check that the first argument to \clocode{map} is a function and the second argument is a sequence, it may be function that is not applicable to the elements of the sequence (such as trying to call \clocode{<} on a string) or expects a wrong number of arguments.

Catching and reformatting Clojure error messages also allows us to simplify the standard stack trace. A complete stack trace of an error message often contains over a hundred Clojure and Java function calls. We approach this issue is by filtering out everything in the stack that is not a part of the student's project (such a project may include some of our own functions added for simplicity). This allows students to see the part of the stack trace that directly relates to their code, and nothing else. 
%\todo{an example of error messages before and after}
%The error message filtering has worked well in tests and gives messages that make sense to beginners. 

When a Clojure throws a Java exception, our procedure for handling it is as follows:
\begin{enumerate}
\item Catch the exception in a {\tt try/catch} block in the Clojure {\tt main} function. 
\item Filter the stack trace, as described above. 
\item Match the class of the exception (e.g.IllegalArgumentException) against a list. 
\item If a matching case is found, attempt to match the message against a list of regular expressions. 
\item If any of the matching message segments are Clojure types, find a corresponding user-friendly type in a ``dictionary''. 
\item Transform the message text according to the pattern corresponding to the matching regular expression, while replacing types according to the type dictionary.  
\item Display the transformed error message. Users also have an option to see the original error message (by opening a separate tab). 
\end{enumerate}
Some sample types translations are given in table~\ref{table:types}, and some sample message transformations are in table~\ref{table:messages}. If no type match can be found, either by a lookup or by checking interfaces that a type implements, %(e.g. a variety of types that represent functions that all implement {\tt IFn} interface)
then we would display the type as an ``unrecognized type'' followed by the actual type. However, as we expand our type dictionary and continue testing, these cases occur less and less frequently. 

Below we give more detailed examples of some of these situations and specific resulting messages. 

Suppose a student uses a predefined, but somewhat less common, function \clocode{drop-while} for which no precondition is provided. The function takes a predicate and a sequence, and removes items in the beginning of the sequence while they satisfy the predicate. Since any non-false and non-nil value in Clojure is considered {\tt true}, the ``predicate'' can be any function applicable to the sequence items. Moreover, since Clojure sequence processing is lazy, the function only needs to be applicable up to the first item in the sequence for which it returns {\tt false}. For instance, \clocode{(drop-while odd? '(1 5 6 "banana"))} (where \clocode{odd?} is a predicate on integers that determines if a number is odd) works without errors and returns \clocode{(6 "banana")}. 

If the first argument is not a function, e.g. \clocode{(drop-while 5 '(1 2 3))}, the Clojure native error message is 

{\tt
java.lang.ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn
}

\noindent
Our modified message is much more understandable:

{\tt
Attempted to use a number, but a function was expected.
}

\noindent
A similar transformation takes place if we pass a number instead of a sequence, for instance \clocode{(drop-while odd? 5)}. The original message is 

{\tt
java.lang.IllegalArgumentException Don't know how to create ISeq from: 

java.lang.Long
}

\noindent
The transformed message is:

{\tt
Don't know how to create a sequence from a number
}

\noindent
Note that, unlike the previous message that required that the first argument was already a function, in this case we require that the argument provides some means for creating a sequence out of it. For example, a string is not a sequence, but it can be turned into a sequence of characters by applying a specific function. Thus there is a difference in wording in the two original error messages (``cannot cast X to Y'' vs ``cannot create Y from X'')  which we reflect in the wording of our more beginner-friendly messages. 

Continuing with the example, we examine what happens when a function passed to \clocode{drop-while} cannot be applied to items of a sequence. Consider the call \clocode{(drop-while odd? '(5 "apple" 6))}. Here \clocode{odd?} is successfully applied to \clocode{5} and then unsuccessfully to a string \clocode{"apple"}. In this case the original message is 

{\tt
java.lang.IllegalArgumentException Argument must be an integer: apple
}

\noindent
On the positive side, the message is reasonably clear: it specifies the argument (\clocode{apple}) and states that it must be an integer. However, the message does not specify which function caused the problem (\clocode{odd?}) or which item of the sequence was to blame (since the sequence could have been returned from another function, we cannot always assume that we can see all the arguments). Unfortunately, based on just the exception that we catch we cannot provide the missing information, so our ``transformed" message is almost the same as the original: 

{\tt
Argument must be an integer: apple
}

\noindent 
The situation may be helped somewhat by providing a precondition for \clocode{odd?} that would at least report that the invalid argument was passed to the function \clocode{odd?} which we currently do not have, but can add. 

Another common source of  errors is passing a wrong number of arguments to a function. These functions can be predefined or user-defined, which can be further subdivided into named and anonymous. Consider the following two examples: \clocode{(drop-while cons '(1 2 3))}, where \clocode{cons} is a function of two arguments, and a user-defined anonymous function of two arguments that simply returns the first one: \clocode{(drop-while (fn [x y] x) '(1 2 3))}. The original error messages are as following:

{\tt
clojure.lang.ArityException Wrong number of args (1) passed to: 

core\$cons

clojure.lang.ArityException  Wrong number of args (1) passed to: 

core\$eval3187\$fn
}

\noindent
Once again, the message is sufficiently informative, although it is missing the expected number of arguments, which is impossible to recover from the error message alone (however, keep in mind that Clojure functions may have a variable number of arguments).  We can improve the function names by removing the reference to {\tt core} that at this point does not make sense to students, and convert the cryptic function name in the second call to just ``anonymous function''. The messages become:

{\tt
Wrong number of arguments (1)  passed to a function cons

Wrong number of arguments (1)  passed to an anonymous function
}

\elenacomment{Need to end this section somehow}


%\elenacomment{cut out from the earlier version, needs rewriting}
% intercepts Clojure errors by providing a {\tt try/catch} block around students' code and reformatting error messages. 
%As an example, consider the following error message for {\tt (cons 2 3)}, i.e. at an attempt to conjoin an element onto something that is not a sequence and cannot be converted to one:
%
%{\tt IllegalArgumentException Don't know how to create ISeq from: java.lang.Long}
%
%While the wording of the message is reasonably clear, the types used in it would not be understandable to beginner programmers at all. {\tt ISeq} is an interface that represents a Clojure sequence, but beginner students are not familiar with interfaces. Numbers in Clojure can be represented as a variety of types, and it is quite common for them to be represented as the {\tt  java.lang.Long} type. The exception type itself also is not useful to beginners for the most part. 
%The error can be made clearer for beginners if we replace type names by those that make sense to beginners and remove the exception type:
%
%{\tt Error: Don't know how to create a sequence from a number}. 

%\elenacomment{Might move it earlier})\joecomment{I would mention the fact that there are testers earlier, and maybe indicate that they are an active part of the improvement process, not simply that we dragged them into a room and forced them to use clojure once} \stephencomment{Added this to the intro}. 
%Among issues that we still need to address, however, are compilation errors which cannot be caught at run time and some errors that show up after {\tt main} finishes due to lazy evaluation. A way to approach this issue would be to use our own run system instead of the one provided with the Clojure project manager Leiningen (see section~\ref{subsec:envt} for details).
%\elenacomment{issues: compilation error messages; laziness and project setup}

\subsubsection{Extending try/catch approach}
Running user code in {\tt try/catch} allows catching and rewriting run-time errors, but there are certain types of errors that cannot be caught this way. Since Clojure is an interpreted language, compile time errors manifest themselves at run time as Java exceptions of the type {\tt CompilerException}. However, given the way a Clojure program is typically run, the error takes place before Clojure \clocode{main} function starts. Therefore such an error bypasses a {\tt try/catch} block in {\tt main}. If an error message bypasses the {\tt try/catch} block, it never gets caught and rewritten, and so it remains the original cryptic Clojure message.

Another possibility for an exception to bypass a {\tt try/catch} block in {\tt main} is via laziness. Clojure sequences are by default lazy, and many predefined function work with them in a lazy manner as well: they compute only as much of a sequence as needed. When a lazy sequence is produced in a Clojure program, it is not computed ({\it realized}, in Clojure terminology) until it is needed. If {\tt main} returns a lazy sequence, it then gets printed to the runtime system. In order to get printed, the sequence needs to be realized. However, since this happens technically outside of {\tt main}, the {\tt try/catch} block is bypassed, and unprocessed exceptions get thrown. 

A similar problem arises when users run their code in REPL: unless they surround their testing code with a {\tt try/catch} block and call the error handling function, they would still be getting native Clojure error messages. 

It is clear that in order to deal with these issues, one needs to use an approach other than a {\tt try/catch} block in {\tt main}. We discuss a possible way of dealing with these issues in Section~\ref{subsec:envt}.

%\elenacomment{Compilation errors, laziness}


\subsection{Development environment}\label{subsec:envt}
Even though new students will start by simply writing code in a basic text editor, their code will typically be a part of a project.
We will provide a template project that contains all of the necessary libraries and project settings and %will provide 
a file for the students to write their code. It includes the exception-catching and reformatting and predefined Clojure functions that we need to supply for students to use in their own code. We can also include libraries, such as a turtle graphics library~\cite{turtle} and a Clojure wrapper for Java Swing (a Java GUI library), called seesaw~\cite{graphics}. The environment makes it possible to run students' code as a complete program (designated in a project setup) as well as in a REPL %\elenacomment{make sure to clarify what that is earlier} 
for interactive testing. 
%Our plan is to provide a template project that contains all of the necessary libraries and project settings \joecomment{This may need to be higher in the paragraph.}. 

Our project, like many Clojure projects, is managed via a command-line tool called Leiningen~\cite{lein}. Leiningen handles dependencies, controls compilation, and allows one to run either a function of the project designated as ``main'' or start a REPL with all of the project's code loaded. 

A good Clojure development environment for beginners %we think that 
 must have the following characteristics: 
\begin{itemize}
\item Provide at least basic syntax highlighting and formatting. 
\item Provide at least the basics of Clojure project management. 
\item Allow incorporation of beginner-friendly error reporting. 
\item Be convenient and easy to understand for beginners.
\item Be reliable and bug-free.
\end{itemize}
Unfortunately, there is no IDE for Clojure that has all these features. 
%Both text editor {\tt emacs} and a plugin for a common Java IDE {\tt Eclipse} are too complicated for beginners \stephencomment{
Advanced text editors, e.g. {\tt emacs}, and the plugin Counterclockwise for the common Java IDE Eclipse, are too complicated for beginners. Several text editors intended specifically for Clojure are still in development stages and are unreliable or lack functionality. We decided to use the text editor {\tt jEdit}~\cite{jedit} which has a plugin for Clojure syntax highlighting, and then manage projects with Leiningen's terminal commands. We are working on creating  a Leiningen plugin that would allow running a program in such a way that beginner-friendly error reporting would be possible not only when running {\tt main}, but also when using REPL, as well as for compilation errors and errors in lazy computations. 

%We are working on creating a jEdit plugin that allows to call Leiningen commands. We also work to enable beginner-friendly error reporting not only when running {\tt main}, but also for compilation errors and those generated while using the REPL. Currently we get original error messages in these  cases since they are outside of the try/catch block in {\tt main}. 

\subsection{Other language modifications}\label{subsec:other}
There are a few functions that may be confusing
%complicated \elenacomment{rephrase "complicated"} functions or those misleading
 for beginners. For instance, the {\tt contains?} function returns {\tt true} if a key is present in a data structure, and not the element. It would return {\tt true} if passed any vector of with a length of at least $2$ and the number $1$, regardless of the actual elements of the vector, since indices in a vector are considered keys. Providing a function with a more intuitive name, such as {\tt 
contains-value?}, would address this issue. 
There are other similar examples that require providing alternatives with more precise names.

%\todo{Error messages, development environment, lack of examples for beginners, some confusing names since they are a part of a full-scale language.}

\section{Approaches to teaching Clojure to beginners}\label{sec:approaches}
\begin{table}[t]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
Name & Example & {\tt seq} & {\tt conj} &  {\tt into}  \\
\hline
list & `(1 2) & {\parbox{3cm}{{\tt (seq `(1 2))} \\ $\Rightarrow$ {\tt (1 2)}}} &
{\parbox{3.5cm}{{\tt (conj `(1 2) 3)} \\ $\Rightarrow$ {\tt (3 1 2)}}} & 
{\parbox{4.2cm}{{\tt (into `(1 2) `(3 4))} \\ $\Rightarrow$ {\tt (4 3 1 2)}}} 
\\
\hline
vector & [1 2] & 
{\parbox{3cm}{{\tt (seq [1 2])} \\ $\Rightarrow$ {\tt (1 2)}}} &
{\parbox{3.5cm}{{\tt (conj [1 2] 3)} \\ $\Rightarrow$ {\tt [1 2 3]}}} & 
{\parbox{4.2cm}{{\tt (into [1 2] `(3 4))} \\ $\Rightarrow$ {\tt [1 2 3 4]}}} 
 \\
\hline
hashmap & \{1 2\} & 
{\parbox{3cm}{{\tt (seq \{1 2\})} \\ $\Rightarrow$ {\tt ([1 2])}}} &
{\parbox{3.5cm}{{\tt (conj \{1 2\} [3 4])} \\ $\Rightarrow$ {\tt \{1 2, 3 4\}}}} & 
{\parbox{4.2cm}{{\tt (into \{1 2\} [[3 4]]} \\ $\Rightarrow$ {\tt \{1 2, 3 4\}}}} 
 \\
\hline
set & \#\{1 2\} & 
{\parbox{3cm}{{\tt (seq \#\{2 1\})} \\ $\Rightarrow$ {\tt (1 2)}}} &
{\parbox{3.5cm}{{\tt (conj \#\{1 3\} 2)} \\ $\Rightarrow$ {\tt \#\{1 2 3\}}
\\ {\tt (conj \#\{1 2\} 2)} \\ $\Rightarrow$ {\tt \#\{1 2\}}}} & 
{\parbox{4.2cm}{{\tt (into \#\{2 3\} [1 4]} \\ $\Rightarrow$ {\tt \#\{1 2, 3 4\}}}} 
 \\
\hline
\end{tabular}
\caption{Some of key Clojure collections and their collection-specific functions}\label{table:coll}
\end{table}
Clojure learners (and even some experienced programmers) are often confused by the fact that Clojure documentation and examples refer to a {\it sequence} and a {\it collection} without clearly explaining the difference between the two. In fact, that difference seems very fuzzy when a function is described as taking a collection as a parameter, returns a sequence, and then the returned value (which was described as a sequence) is passed to another function which also, according to its documentation, takes a collection. For instance, the result of \clocode{filter} (a sequence) is passed to \clocode{map} whose parameter is described as a collection.  Not understanding this difference in terminology signals a lack of depth in understanding of Clojure as a language.

A seemingly unrelated problem is confusion about the use of functions \clocode{conj} and \clocode{into}, i.e. functions that add elements to a collection, on predefined Clojure collections. The order in which elements are added to the collection is often not what a programmer expects, there are unexpected {\tt IllegalArgument} errors, and Clojure programmers, especially less experienced ones, often resort to trial an error in order to decide, for example, if they should use a list or a vector (described below).

Principles behind collections and sequences are known in the Clojure community (see~\cite{JC}), but are not necessarily clearly explained to new Clojure programmers. We argue that a teaching approach that centers on the sequence abstraction and the conceptual differences between collections and sequences provides a solid understanding of the language and the ability to utilize its resources to write modular and less error-prone programs. Below we describe our approach and a small addition to Clojure that supports it. 

\subsection{Clojure sequences and collections}\label{seq-abstr}
Clojure sequences are structures that contain some (possibly infinite) number of elements in any order. Internal implementations of sequences may differ, but these differences are not observable to the rest of the program. Sequences support functions that access elements in order, such as \clocode{first} (returns the first element in a sequence), \clocode{rest} (returns a sequence of all elements except the first one, in order). Most general functions, e.g. \clocode{map, reduce, filter} return sequences. There are no guarantees of efficiency of specific operations on sequences. Thus a sequence can be viewed as an abstraction for an ordered group of elements. 

Unlike a sequence, a collection refers to a particular storage structure for a group of elements. Clojure provides a rich set of immutable collections. Each collection serves a different purpose, and its  implementation  is typically optimized for efficiency based on its intended use. The four most commonly used Clojure collections are a {\it list}, a {\it vector}, a {\it hash map}, and a {\it set}. Lists are singly-linked lists, similar to Common Lisp lists, vectors are a highly efficient data structure for both insertion and deletion at any position in a logarithmic time, hash maps are collections of key/value pairs, and sets are unordered collections of elements in which every element occurs at most once. 

Each Clojure collection supports three functions that provide a uniform way of interacting with it. However, the implementation, and therefore the behavior of each of these functions is different for different collections. The functions are as follows:
\begin{itemize}
\item \clocode{conj} that takes a collection and an item and returns a new collection {\it of the same type} with the new element added to the collection. 
\item \clocode{into} that takes a collection and a sequence of elements and adds all of these elements to the collection. \clocode{into} is implemented by adding each element of the collection (in order) using \clocode{conj}. 
\item \clocode{seq} takes a collection and produces its corresponding sequence. 
\end{itemize}

The first two columns of table~\ref{table:coll} list and give (syntactic) examples of four most commonly used data structures:


For instance,Creating a new list from an existing one can be done in a constant time when an element is added or removed from the beginning by taking advantage of sharing the rest of the elements. %after the one we are adding or removing. %The new list is just a reference to its first element.
However, adding an element at the end takes linear time since the entire list needs to be copied. 
Vectors are a highly efficient data structure for both insertion and deletion at any position in a logarithmic time.
%: $log_{32} N$, where $N$ is the number of elements in the vector. 
They are implemented as shallow trees so that everything that is not on the path to a changed element can be shared between the old vector and the new one.
% constructed out of it. Hash-maps and sets are also optimized in their own way for efficient creation of modified versions via insertion, deletion, or modification. 
\elenacomment{show syntax}

A function {\tt conj} that adds an element to a collection, returning the result as a collection of the same type as the original, positions the element in the most efficient way for this type of a collection. Thus it adds it at the beginning for a list and at the end for a vector. 
\elenacomment{show code}
While this makes sense from the language implementation standpoint, this behavior is very confusing for new programmers. 

Most functions on collections, however, are not collection-specific: they take any collection that can be converted into a sequence of elements in some order, and return a sequence, rather than a specific collection. For instance, {\tt map} that maps a function
%, such as ``add 5'', 
over all elements of a collection, returns a sequence regardless of what kind of collection was passed to it. Sequences are stored as list-like structures, or as a different implementation (e.g. as lazy sequences), but they all function exactly the same in relation to all function that they can be passed to. 
\elenacomment{mention seq}

\elenacomment{show into example and reverse example}

Encouraging students to program in a collection-independent way, i.e. using a sequence abstraction, helps them focus on the concepts, rather than specifics of collections implementations. We provide collection-independent functions in a few cases when they do not exist, such as {\tt add-last} that adds an element to a collection at the end, returning the result as a sequence. We also provide examples of handling data in a collection-independent way since most  examples in Clojure forums and documentation use collection-specific functions for efficiency. Students will see both collection-specific and collection-independent functions which would provide a good understanding of abstraction and its benefits. 

%Because the 

%\todo{Clojure concepts: sequence abstraction vs concrete collections, laziness; providing examples for beginners + knowledge of complete language to understand other examples.}

\section{Conclusions}
Clojure is a promising candidate for an introductory CS course. Its rich collection of data structures and focus on abstraction teaches students good programming skills. The growing use of Clojure in industry means that there is an active and helpful community surrounding the language which helps students to continue Clojure development after the introductory course. However, in order to adopt Clojure as a language for an introductory class one needs to tackle a few challenges, such as confusing errors messages and  a lack of beginner-friendly development environments.

\section{Acknowledgments}
The authors thank Jon Anthony, Brian Goslinga, Nic McPhee, and Simon Hawkin for helpful discussion and suggestions, %\joecomment{Use the word input? Or else it sounds like we just enjoy talking to them and that deserves mentioning :)}. 
Max Magnuson and Paul Schliep for thorough testing of our development environment, and participants at TFPIE 2013 for their feedback and discussion. 

%\elenacomment{+ Nic and TFPIE}

\bibliographystyle{eptcs}
\bibliography{overview}
\end{document}



%Sample stuff from example for now.

%We request that you use
%\href{http://www.cse.unsw.edu.au/~rvg/EPTCS/eptcs.bst}
%{\tt $\backslash$bibliographystyle$\{$eptcs$\}$}
%\cite{bibliographystylewebpage}. Compared to the original {\LaTeX}
%{\tt $\backslash$biblio\-graphystyle$\{$plain$\}$},
%it ignores the field {\tt month}, and uses the extra
%bibtex fields {\tt eid}, {\tt doi}, {\tt ee} and {\tt url}.
%The first is for electronic identifiers (typically the number $n$
%indicating the $n^{\rm th}$ paper in an issue) of papers in electronic
%journals that do not use page numbers. The other three are to refer,
%with life links, to electronic incarnations of the paper.
%
%Almost all publishers use digital object identifiers (DOIs) as a
%persistent way to locate electronic publications. Prefixing the DOI of
%any paper with {\tt http://dx.doi.org/} yields a URI that resolves to the
%current location (URL) of the response page\footnote{Nowadays, papers
%  that are published electronically tend
%  to have a \emph{response page} that lists the title, authors and
%  abstract of the paper, and links to the actual manifestations of
%  the paper (e.g.\ as {\tt dvi}- or {\tt pdf}-file). Sometimes
%  publishers charge money to access the paper itself, but the response
%  page is always freely available.}
%of that paper. When the location of the response page changes (for
%instance through a merge of publishers), the DOI of the paper remains
%the same and (through an update by the publisher) the corresponding
%URI will then resolve to the new location. For that reason a reference
%ought to contain the DOI of a paper, with a life link to corresponding
%URI, rather than a direct reference or link to the current URL of
%publisher's response page. This is the r\^ole of the bibtex field {\tt doi}.
%DOIs of papers can often be found through
%\url{http://www.crossref.org/guestquery};\footnote{For papers that will appear
%  in EPTCS and use \href{http://www.cse.unsw.edu.au/~rvg/EPTCS/eptcs.bst}
%  {\tt $\backslash$bibliographystyle$\{$eptcs$\}$} there is no need to
%  find DOIs on this website, as EPTCS will look them up for you
%  automatically upon submission of a first version of your paper;
%  these DOIs can then be incorporated in the final version, together
%  with the remaining DOIs that need to found at DBLP or publisher's webpages.}
%the second method {\it Search on article title}, only using the {\bf
%surname} of the first-listed author, works best.  
%Other places to find DOIs are DBLP and the response pages for cited
%papers (maintained by their publishers).
%{\bf EPTCS requires the inclusion of a DOI in each cited paper, when available.}
%
%Often an official publication is only available against payment, but
%as a courtesy to readers that do not wish to pay, the authors also
%make the paper available free of charge at a repository such as
%\url{arXiv.org}. In such a case it is recommended to also refer and
%link to the URL of the response page of the paper in such a
%repository.  This can be done using the bibtex fields {\tt ee} or {\tt
%url}, which are treated as synonyms.  These fields should not be used
%to duplicate information that is already provided through the DOI of
%the paper.
%You can find archival-quality URL's for most recently published papers
%in DBLP---they are in the bibtex-field {\tt ee}. In fact, it is often
%useful to check your references against DBLP records anyway, or just find
%them there in the first place.
%
%When using {\LaTeX} rather than {\tt pdflatex} to typeset your paper, by
%default no linebreaking within long URLs is allowed. This leads often
%to very ugly output, that moreover is different from the output
%generated when using {\tt pdflatex}. This problem is repaired when
%invoking \href{http://www.cse.unsw.edu.au/~rvg/EPTCS/breakurl.sty}
%{\tt $\backslash$usepackage$\{$breakurl$\}$}: it allows linebreaking
%within links and yield the same output as obtained by default with
%{\tt pdflatex}. 
%When invoking {\tt pdflatex}, the package {\tt breakurl} is ignored.
%
%%\nocite{*}
%%\bibliographystyle{eptcs}
%%\bibliography{generic}
%\end{document}
