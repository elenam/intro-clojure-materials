\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TBA} % Name of the event you are submitting to
\usepackage{url}
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{color}

\newcommand{\allcomments}[1]{{#1}}
%\newcommand{\allcomments}[1]{}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{StephensBlue}{RGB}{0,204,204}
\definecolor{JoesGold}{RGB}{204,102,0}
% Uncomment this if you don't want to show comments
\newcommand{\elenacomment}[1]{{\bf \textcolor{ForestGreen}{\allcomments{{#1}}}}}
\newcommand{\stephencomment}[1]{{\bf \color{StephensBlue}{\allcomments{{#1}}}}} %%%  or pick your color
\newcommand{\joecomment}[1]{{\bf \color{JoesGold}{\allcomments{{#1}}}}}
\newcommand{\todo}[1]{{\bf \color{magenta}{\allcomments{ To-do: {#1}}}}}
% \renewcommand{\elenacomment}[1]{}


\title{Benefits of teaching the Clojure programming language in an introductory CS class and approaches to teaching it.}
\author{Elena Machkasova 
\institute{University of Minnesota, Morris
\email{elenam@morris.umn.edu}}
\and
Stephen J Adams 
\institute{\email{adams601@morris.umn.edu}}
\and 
Joe Einertson 
\institute{University of Minnesota, Morris
\email{eine0017@morris.umn.edu}}
}
\def\titlerunning{TBA}
\def\authorrunning{TBA}
\begin{document}
\maketitle

\begin{abstract}
Abstract goes here.
\end{abstract}

\section{Introduction}

%\joecomment{Any particular reason I'm listed as Joseph rather than Joe? Either one is fine but Joe is what I usually go by/is most Googleable}
%\joecomment{Typo in the title. Pick either 'of' or 'to' in the beginning.}
\todo{Mention the state of work in progress}


\section{Overview and history of Clojure}
Clojure is a dialect of Lisp developed by Rich Hickey and released in 2007~\cite{Hickey:2008}. Clojure was developed to answer the need for a practical  functional language that supports convenient, efficient, and safe programming for concurrency. Clojure provides a rich set of immutable data structures, augmented with several kinds of mutable reference types. Clojure in its classical implementation is complied into Java bytecode and can be fully integrated with Java, both by using Java objects and methods and by providing code that can be invoked from Java. It was carefully designed with efficiency in mind, and provides constructs for tail call optimization,
%(at compilation time, due to Java's lack of support of tail call optimizations) 
%\joecomment{Is this comment necessary? doesn't really relate to the topic of the paper}\elenacomment{people who knwo that Java doesn't do TCO may be surprised otherwise, but fair enough, we need to cut something.}
data structures with fast traversal to any element that maximize sharing when a modified version is created, and efficient handling of lazy structures, among other mechanisms for providing efficiency. As the result, Clojure is as fast as Java on its underlying platform (the JVM) \joecomment{Is this proven? Clojure is very fast, but I have never seen a performance analysis that shows Clojure is as fast as native Java code (due to its dynamic nature, yadda yadda ya)}\elenacomment{is commonly considered to be?}, and much more effective %\stephencomment{I think we should specify that this is programmer efficiency rather than runtime efficiency} \elenacomment{Actually, it's run-time efficiency due to lack of waiting for locks. But we can say "effective" instead of "efficient" if you think that's better} \stephencomment{I fine with "effective"} 
for concurrent execution due to immutability of data structures and significantly reduced need for locking and synchronization. 

Because of its convenience, efficiency, and elegant design 
%\stephencomment{I'm not quite sure what you mean by model. Is this something that will be familiar to the audience?} \elenacomment{how about design?} \stephencomment{better} 
Clojure is rapidly gaining popularity in the software development community. \elenacomment{data goes here; perhaps reference some papers, perhaps the bioinformatics paper? Searching on "clojure" in ACM digital library gives some useful stuff.}
\elenacomment{Perhaps combine some sections, make them subsections.}

\section{Benefits of teaching Clojure as the first language}

\subsection{Overview of an introductory CS course and its role in CS curriculum}
%\joecomment{Capitalizing computer science feels (is) incorrect. Also, I don't know what the distribution of this paper will be, but college has a very different connotation (trade school/community college) in most of the rest of the world. I would use university instead.} 
In this work we explore incorporating Clojure into an introductory undergraduate computer science course. We describe the course setup at UMM which is fairly typical for a small university. At UMM we have about 3.5 contact hours per week that include lecture and lab time and other activities, e.g. group discussions. There are 30-40 students in the course that  include CS majors/minors, undecided students with  interest in CS, and those taking it to satisfy an elective requirement for another discipline (e.g. math) or as a general education course. The majority of the students (even those who intend to major in CS) do not have any prior programming experience and very little understanding of the process of computing. 
%\stephencomment{This paragraph seems unnecessarily generic especially since the next two paragraphs talk fairly specifically about our program with very "concrete" language. I think we can reword it to talk more specifically about Morris's program or at least in the 1st person plural. Rather than saying "Such a course has" we could say "We have about 3.5 contact hours" thoughts?}\elenacomment{I suppose. I am not entirely sure how this is typically written. I can rephrase it}

The course focuses on general problem solving and its specifics as related to computer science 
\stephencomment{"The course focuses on general problem solving and the specifics of implementing solutions in a programming language."?? I feel like the second half of this sentence should be a little less vague.}. 
\elenacomment{I don't think it's just a programming language connection. I meant generally the way computers operate. So I'd argue for my wording.}
Students work on understanding a problem's requirements and gradually develop solutions in a programming language, with an emphasis on effective design and testing strategies. In the process they learn about language syntax and behavior, key programming concepts such as conditionals and functions, data representation in a program, and similar introductory-level concepts. Mastering the concept of recursion is one of the key learning objectives in the course since it is a basis of many important data structures and algorithms. 
%\stephencomment{Perhaps expand on why we value recursion?}. 
Towards the end of the course students develop their own implementations of simple searching and sorting algorithms and are informally introduced to the notion of big-O. Course exercises include both concrete assignments and open-ended projects, such as graphics and simple game development. Students often work in groups which promotes inter-personal communication and a code style that communicates intention. 

Students continuing in the CS program would take a version of a discrete mathematics class as their second CS  course and Data Structures (in Java) as the next course that involves programming. The rest of our curriculum incorporates a variety of languages and systems, but assumes solid understanding of Java by all students. 
%It is important to note that not all students in subsequent CS courses have come from this introductory course: at UMM, for instance, we have an alternative entry point for the CS major that explores the same introductory concepts using digital media (images, music, etc.) and the Python programming language, to better accommodate students who approach CS from the design and artistic standpoints. \elenacomment{while this is important from the practical standpoint, I am not sure we have room for this here} \stephencomment{Doesn't seem super necessary from this paper's perspective.}

%\todo{A bit about assumed setup of CS curriculum; learning goals}

\subsection{Benefits of teaching Clojure in an introductory class}
The benefits of using a functional programming language in introductory computer science classes are well-known  \elenacomment{a citation?}. Functional languages focus on functions as programming units, provide abstraction, generalization, and modularity, and give a better understanding of recursion, one of the key learning goals in an introductory course. 
%\elenacomment{I moved explanation of why recursion is important to the earlier section}
Functional languages tend to have simpler, more uniform syntax that students master quickly. There are several successful introductory curricula that use functional languages, including the How To Design Programs curriculum using a Lisp dialect Racket~\cite{htdp} and introductory courses that use Haskell, e.g.~\cite{haskell}.

%\elenacomment{reference Racket, Haskell, ML?}\stephencomment{I think Racket definitely should be mentioned here. Not so sure about the other two. I know that Harvard uses a little ML, but Kent is the first school that I've heard of using Haskell for their intro classes and they are switching to Erlang next year.}\elenacomment{My colleagues in Frankfurt teach Haskell. I think it's fairly common in Europe. Less sure about ML, I don't know of anyone who teaches it as the first language} \stephencomment{Harvard seem to be using OCaml in their second CS course for majors (CS51) which seems to be a lot about OO programming. Either way they are the only school I've heard of using it but since it's Harvard there are sure to be imitators. It seems that Racket and Haskell should be mentioned, ML maybe not as much.}

Developing a similar undergraduate curriculum based on Clojure would provide additional benefits. 
Clojure is a language that was 
%developed for real-life software development \stephencomment{"developed for use in industry" or "
%\joecomment{I like Stephen's other suggestion of "for use in industry" better. Industrial software development parses ambiguously (we are not talking about a factory which generates code)}
developed for use in industry. It combines a rich set of features (including a variety of mechanisms for concurrency) with an elegant uniform underlying model based on abstraction. Clojure ``collections'' (i.e. data structures) include lists, vectors, sets, and hashmaps. However, 
%all of them can be worked with as sequences \stephencomment{"
all of these collections can be worked with as sequences. (more on this in section~\ref{sec:approaches}). 
%While it would be impossible (and unnecessary) to present all of Clojure's features in an undergraduate course, 
Abstraction-based program development teaches students use and appreciate abstraction and modularity in their own solutions. A uniform abstraction-based language model also makes it easier for students to learn language features and libraries not covered in class on their own. 
%Understanding the underlying abstractions and concepts makes it easier for students to build upon what they learn in the class.
%%\stephencomment{End sentence here} and learn on their own. 
%The underlying abstractions also teach students about a good language design and problem solving that focuses on the essence of the problem and not on specifics of a given structure. \elenacomment{talk about focus on abstraction}

%\elenacomment{Make it clear that these benefits are as students move forward}
Clojure is beneficial in preparing students for moving forward in the CS program. 
Clojure is fully integrated with Java since both compile to Java bytecode: Java code can be called from Clojure and vice versa.
%, and Clojure code can be called from Java  \joecomment{and vice versa?}. 
Integration with Java does not have an efficiency penalty for either of the languages. 
%It is important to keep in mind that Clojure integrates with Java without losing efficiency, and Clojure itself is as efficient as Java and does not impede Java optimizations. 
%As students continue in the CS curriculum\stephencomment{??} \elenacomment{better (changed the rest of the sentence slightly as well)? This may address your later question as well}, 
Students can  integrate Clojure into projects developed in Java or labs that use pre-written Java code in their upper-division classes, allowing them to incorporate functional style of programming as needed, even in a part of a project. 
%This gives students a choice of languages and paradigms 
%that can be made by a student or a group individually \joecomment{everything from "that can..." is redundant: "This gives students a choice...that can be made by a student"}, 
%without need for uniformity with the rest of the class or the rest of the project.\stephencomment{I think this paragraph needs to clarify what Java interop accomplishes for intro students. I'm not seeing how this would be successfully incorporated into 1301 from what you say here.} \elenacomment{I don't think intro students will be using Java interop. Not sure what you mean.} \stephencomment{We are in the "Benefits of teaching Clojure in an introductory class" subsection and started talking about Java interop so I got a little confused when intro students would be using these features. If we want to mention how our curriculum leads into Java code and that introducing Clojure in our intro class can ease the transition into Java.}

A related benefit is Clojure's suitability for concurrency. Clojure provides mechanisms for multithreading that do not require explicit thread synchronization,  locks, 
%objects \joecomment{object locking? Locking objects sounds like a weird euphemism for safes or keys or something}, 
or adjustments to the number of processors. While Clojure concurrency cannot be fully covered in an introductory course, background in Clojure makes it easy for students to learn this material in a later course.
% or, if need be \joecomment{I think this interjection is unnecessary.}, independently for a project or an internship. 
The students would already be familiar with key concepts, such as immutable persistent data structures. Clojure fits the recent 
emphasis on teaching concurrency in undergraduate curriculum (e.g.~\cite{Brown:2010}) perfectly. 

Clojure has a friendly, well-developed
%\elenacomment{added "friendly" - thoughts?} \stephencomment{I haven't had any problems with people and I'm sure conference attendees will know that this is an issue with several FP communities.} \joecomment{Swapped word order so sentence flows better.}
community with online community-maintained documentation and examples, multiple blogs, several Google groups and an IRC channel, numerous open-source projects, a large number of meetups in many cities, and several excellent quality books (although not at a beginning programmer level). All these resources would enable students to continue their Clojure development past the introductory course. 
%\stephencomment{I feel like the biggest issue with this subsection is that it is supposed to be about what Clojure has to offer introductory students. However a large section of it is about two fairly advanced features (interop, and concurrency) that don't seem to be useful to an introductory student. If you are trying to talk about these advanced features as helpful for transitioning intro students into higher level classes I think that needs to be more explicit.}\elenacomment{Good point. Will change.}
\joecomment{This section feels a little disorganized in places, but makes many good points. I would try to improve the flow by leading from each paragraph/point into the next.}

%\todo{Benefits of teaching Clojure to undergrads: provides all the benefits of teaching functional first, integrates with Java,  is used in industry and becoming quite popular (availability of examples), is done right, is a great language to program for oneself, introduces parallel computation}

\section{Technical challenges of teaching Clojure as the first language}
The key technical (as opposed to conceptual) challenges of teaching Clojure to beginners stem from the fact that it was not designed as a language for beginners. Clojure currently does not have a beginner-friendly development environment. Another significant problem is that Clojure error messages come directly from Java and mention Java types and other notions (such as null pointer exceptions) that do not appear directly in Clojure (Clojure is implicitly typed) and are not understandable to beginners. There are a few common functions with names that may be misleading to new students. Below we describe our work developing a custom environment that addresses these problems.

\subsection{Error messages}\label{subsec:errors}
Clojure error messages are Java exceptions and therefore mention Java types (some native to Java and some coming from Clojure's implementation in Java) that are unclear to beginners, especially because Clojure is dynamically typed with no need need to specify types explicitly. 
%, and as a beginner you never have to specify any types explicitly \joecomment{This last part should be clarified. It reads like all beginners are magically exempt from explicit typing}. 
Types used in Clojure implementation form a rich Java hierarchy; for instance, numerous types implement an interface that represents a Clojure sequence type. 
%\stephencomment{awk} \elenacomment{I'll think about phrasing here} \joecomment{A semicolon rather than parenthetical phrase would make this read less confusingly.}. 
These details do not matter to students, but would get in the way of their learning experience. There are other cases when an error message does not make sense to new students at all, such as {\tt NullPointerException}. 

\begin{table}
\centering
\begin{tabular}{|c|c|}
\hline
Original type & Beginner-friendly type \\
\hline
java.lang.Number & a number \\
java.lang.Integer & a number \\
java.lang.Double  & a number \\
java.lang.Float & a number \\
java.lang.String & a string \\
java.lang.Character & a symbol \\
clojure.lang.Symbol  & a symbol \\
clojure.lang.ISeq & a sequence \\
\hline
\end{tabular}
\caption{Sample type conversion}\label{table:types}

\end{table}

 \begin{table}
\begin{tabular}{|c|c|c|}
\hline
Exception type & Original message & Beginner-friendly message \\
\hline 
{\tt ClassCastException} & $X$ cannot be cast to $Y$ & {\parbox{5cm}{Attempted to use $X'$, \\ 
but $Y'$ was expected.}} \\[0.3cm]
\hline
{\tt IllegalArgumentException} & 
Don't know how to create $X$ from:  $Y$ & 
{\parbox{5cm}{Don't know how to \\ create  $X'$ from $Y'$}} \\[0.3cm]
\hline
{\tt IndexOutOfBoundsException} & $n$ & {\parbox{5cm}{An index in a sequence \\ 
is out of bounds. The index is: $n$}} \\[0.3cm]
\hline
{\tt NullPointerException} & -- &  {\parbox{5cm}{An attempt to access a 
\\ non-existing object
\\ (NullPointerException)}} \\[0.3cm]
\hline
\end{tabular}
\caption{Sample message wording conversion. $X,Y$ are the original types, $X',Y'$ are the corresponding beginner-friendly types. }\label{table:messages}
\end{table}
%\elenacomment{mention earlier that we are developing an environment}
The run-time environment that we are developing intercepts Clojure errors by providing a {\tt try/catch} block around students' code and reformatting error messages. 
As an example, consider the following error message for {\tt (cons 2 3)}, i.e. at an attempt to {\tt cons} an element onto something that is not a sequence and cannot be converted to one:

{\tt IllegalArgumentException Don't know how to create ISeq from: java.lang.Long}

While the wording of the message is reasonably clear, the types used in it would not be understandable to beginner programmers at all. {\tt ISeq} is an interface that represents a Clojure sequence, but beginner students are not familiar with interfaces. Numbers in Clojure can be represented as a variety of types, and it is quite common for them to be represented as the {\tt  java.lang.Long} type. The exception type itself also is not useful to beginners for the most part. 

The error can be made clearer for beginners if we replace type names by those that make sense to beginners and remove the exception type:

{\tt Error: Don't know how to create a sequence from a number}. 

Table~\ref{table:types} shows more examples of type conversion. If no type match can be found, either by a lookup or by checking interfaces that a type implements (e.g. a variety of types that represent functions that all implement {\tt IFn} interface), then we would display the type as an ``unrecognized type'' followed by the actual type. However, as we expand our type dictionary and continue testing, these cases occur less and less frequently. 

There are other error messages that require conversion to more beginner-friendly wording; see table~\ref{table:messages} for examples. 

Catching and reformatting Clojure error messages also allows us to simplify the standard stack trace. A complete stack trace of an error message often can contain over a hundred Clojure and Java function calls. The way we approach this issue is by filtering out everything in the stack that is not a part of the student's project (such a project may include some of our own functions added for simplicity). This allows students to see the part of the stack trace that directly relates to their code, and nothing else. 

%\todo{an example of error messages before and after}

The error message filtering has worked well in tests and gives messages that make sense to beginners (our testing group includes two sophomores with no prior experience with Clojure \elenacomment{Might move it earlier}). Among issues that we still need to address, however, are compilation errors which cannot be caught at run time and some errors that show up after {\tt main} finishes due to lazy evaluation. A way to approach this issue would be to use our own run system instead of the one provided with the Clojure project manager leinigen (see section~\ref{subsec:envt} for details).
%\elenacomment{issues: compilation error messages; laziness and project setup}

\subsection{Development environment}\label{subsec:envt}
Even though new students start off by simply writing code in a basic text editor, their code would typically be a part of a project. This project provides the exception-catching and reformatting and some predefined Clojure functions that we need to supply for students to use in their own code. There are also some libraries, such as a turtle graphics library~\cite{turtle} and a Clojure wrapper around Java Swing (a Java GUI library), called seesaw~\cite{graphics}, that students will be using. We would like to be able to run students' code as a complete program (designated in a project setup) as well as in a REPL \elenacomment{make sure to clarify what that is earlier} for interactive testing. Our plan is to provide a template project that contains all of the necessary libraries and project settings. 

Our project, like many Clojure projects, is managed via a command-line tool called leiningen~\cite{lein}. Leiningen manages dependencies, controls compilation, and allows one to run either a function of the project designated as ``main'' or start a REPL with all of the project's code loaded. 

In order to serve as a truly fitting Clojure development environment for beginner programmers, an IDE must have the following characteristics: 
\begin{itemize}
\item Provide at least basic syntax highlighting and formatting. 
\item Provide at least the basics of Clojure project management. 
\item Report errors in a reasonable way, with line numbers. 
\item Be convenient and easy to understand. 
\item Be reliable and bug-free.
\end{itemize}
Unfortunately, there is not a perfect IDE for Clojure. 
%Both text editor {\tt emacs} and a plugin for a common Java IDE {\tt Eclipse} are too complicated for beginners \stephencomment{
Non-beginners text editors, e.g. {\tt emacs}, and the plugin for the common Java IDE, Eclipse, are too complicated for beginners. There are several text editors developed specifically for Clojure, but they are still in development stages and are currently unreliable or lack functionality. Our current decision is to go with the text editor {\tt jEdit}~\cite{jedit} which provides Clojure syntax highlighting, and manage projects with leiningen's terminal commands.  We are working on creating a jEdit menu that calls leiningen commands.

We are also working on enabling beginner-friendly error reporting not only when running {\tt main}, but also for compilation errors and those generated while using the REPL. Currently we still get unconverted error messages in these two cases because they are outside of the try/catch block in {\tt main}. 

\subsection{Other language modifications}\label{subsec:other}
There are a few functions that we would like to provide as an alternative to complicated functions or those misleading for beginners. For instance, the {\tt contains?} function returns {\tt true} if a key is present in a data structure, and not the element. This means that it would return {\tt true} if passed any vector of with a length of at least $2$ and the number $1$, regardless of the actual elements of the vector, since indices in a vector are considered keys. Providing a function with a more intuitive name, such as {\tt contains-value?}, would solve this issue. There are other similar examples of functions that may confuse beginners, and we are providing alternatives with more precise names.

%\todo{Error messages, development environment, lack of examples for beginners, some confusing names since they are a part of a full-scale language.}

\section{Approaches to teaching Clojure to beginners}\label{sec:approaches}
As mentioned previously, Clojure provides a rich set of immutable collections : lists, vectors, sets, hash-maps. Each collection has a specific implementation in Clojure. For instance, lists are singly-linked lists, similar in a concept to Common Lisp lists that are a chain of cons-cells. Creating a new list from an existing one can be done in constant time when an element is added or removed from the beginning since it takes advantage of sharing the rest of the elements after the one we are adding or removing. The new list is just a reference to its first element. However, adding an element at the end takes linear time since the entire list needs to be copied. 

Vectors are a highly efficient data structure for both insertion and deletion at any position in a close to constant time: $log_{32} N$, where $N$ is the number of elements in the vector. Vectors are represented internally as shallow trees so that everything that is not on the path to a changed element can be shared between the old vector and the new one constructed out of it. Hash-maps and sets are also optimized in their own way for efficient creation of modified versions via insertion, deletion, or modification. 

%Because the 

\todo{Clojure concepts: sequence abstraction vs concrete collections, laziness; providing examples for beginners + knowledge of complete language to understand other examples.}

\section{Conclusions}

\section{Acknowledgments}
The authors thank Jon Anthony, Brian Goslinga, and Simon Hawkin for helpful discussion. We also thank Max Magnuson and Paul Schliep for thorough testing of our Clojure development environment. 

%\section{Bibliography}

\bibliographystyle{eptcs}
\bibliography{overview}
\end{document}



Sample stuff from example for now.

%We request that you use
%\href{http://www.cse.unsw.edu.au/~rvg/EPTCS/eptcs.bst}
%{\tt $\backslash$bibliographystyle$\{$eptcs$\}$}
%\cite{bibliographystylewebpage}. Compared to the original {\LaTeX}
%{\tt $\backslash$biblio\-graphystyle$\{$plain$\}$},
%it ignores the field {\tt month}, and uses the extra
%bibtex fields {\tt eid}, {\tt doi}, {\tt ee} and {\tt url}.
%The first is for electronic identifiers (typically the number $n$
%indicating the $n^{\rm th}$ paper in an issue) of papers in electronic
%journals that do not use page numbers. The other three are to refer,
%with life links, to electronic incarnations of the paper.
%
%Almost all publishers use digital object identifiers (DOIs) as a
%persistent way to locate electronic publications. Prefixing the DOI of
%any paper with {\tt http://dx.doi.org/} yields a URI that resolves to the
%current location (URL) of the response page\footnote{Nowadays, papers
%  that are published electronically tend
%  to have a \emph{response page} that lists the title, authors and
%  abstract of the paper, and links to the actual manifestations of
%  the paper (e.g.\ as {\tt dvi}- or {\tt pdf}-file). Sometimes
%  publishers charge money to access the paper itself, but the response
%  page is always freely available.}
%of that paper. When the location of the response page changes (for
%instance through a merge of publishers), the DOI of the paper remains
%the same and (through an update by the publisher) the corresponding
%URI will then resolve to the new location. For that reason a reference
%ought to contain the DOI of a paper, with a life link to corresponding
%URI, rather than a direct reference or link to the current URL of
%publisher's response page. This is the r\^ole of the bibtex field {\tt doi}.
%DOIs of papers can often be found through
%\url{http://www.crossref.org/guestquery};\footnote{For papers that will appear
%  in EPTCS and use \href{http://www.cse.unsw.edu.au/~rvg/EPTCS/eptcs.bst}
%  {\tt $\backslash$bibliographystyle$\{$eptcs$\}$} there is no need to
%  find DOIs on this website, as EPTCS will look them up for you
%  automatically upon submission of a first version of your paper;
%  these DOIs can then be incorporated in the final version, together
%  with the remaining DOIs that need to found at DBLP or publisher's webpages.}
%the second method {\it Search on article title}, only using the {\bf
%surname} of the first-listed author, works best.  
%Other places to find DOIs are DBLP and the response pages for cited
%papers (maintained by their publishers).
%{\bf EPTCS requires the inclusion of a DOI in each cited paper, when available.}
%
%Often an official publication is only available against payment, but
%as a courtesy to readers that do not wish to pay, the authors also
%make the paper available free of charge at a repository such as
%\url{arXiv.org}. In such a case it is recommended to also refer and
%link to the URL of the response page of the paper in such a
%repository.  This can be done using the bibtex fields {\tt ee} or {\tt
%url}, which are treated as synonyms.  These fields should not be used
%to duplicate information that is already provided through the DOI of
%the paper.
%You can find archival-quality URL's for most recently published papers
%in DBLP---they are in the bibtex-field {\tt ee}. In fact, it is often
%useful to check your references against DBLP records anyway, or just find
%them there in the first place.
%
%When using {\LaTeX} rather than {\tt pdflatex} to typeset your paper, by
%default no linebreaking within long URLs is allowed. This leads often
%to very ugly output, that moreover is different from the output
%generated when using {\tt pdflatex}. This problem is repaired when
%invoking \href{http://www.cse.unsw.edu.au/~rvg/EPTCS/breakurl.sty}
%{\tt $\backslash$usepackage$\{$breakurl$\}$}: it allows linebreaking
%within links and yield the same output as obtained by default with
%{\tt pdflatex}. 
%When invoking {\tt pdflatex}, the package {\tt breakurl} is ignored.
%
%%\nocite{*}
%%\bibliographystyle{eptcs}
%%\bibliography{generic}
%\end{document}
