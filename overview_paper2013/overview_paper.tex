\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TBA} % Name of the event you are submitting to
\usepackage{url}
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{color}

\newcommand{\allcomments}[1]{{#1}}
%\newcommand{\allcomments}[1]{}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{StephensBlue}{RGB}{0,204,204}
% Uncomment this if you don't want to show comments
\newcommand{\elenacomment}[1]{{\bf \textcolor{ForestGreen}{\allcomments{{#1}}}}}
\newcommand{\stephencomment}[1]{{\bf \color{StephensBlue}{\allcomments{{#1}}}}} %%%  or pick your color
\newcommand{\todo}[1]{{\bf \color{magenta}{\allcomments{ To-do: {#1}}}}}
% \renewcommand{\elenacomment}[1]{}


\title{Benefits of to teaching the Clojure programming language in an introductory CS class and approaches to teaching it.}
\author{Elena Machkasova 
\institute{University of Minnesota, Morris\\
\email{elenam@morris.umn.edu}}
\and
Stephen Adams 
\institute{???}
\email{\quad tba@tba}
}
\def\titlerunning{TBA}
\def\authorrunning{TBA}
\begin{document}
\maketitle

\begin{abstract}
Abstract goes here.
\end{abstract}

\section{Introduction}

\section{Overview and history of Clojure}
Clojure  is a dialect of Lisp developed by Rich Hickey and released in 2007~\cite{Hickey:2008}. Clojure was developed to answer the need for a practical  functional language that supports convenient, efficient, and safe programming for concurrency. Clojure provides a rich set of immutable data structures, augmented with several kinds of mutable reference types. Clojure in its classical implementation is complied into Java bytecode and can be fully integrated with Java, both by using Java objects and methods and by providing code that can be invoked from Java. It was carefully designed with efficiency in mind, and provides constructs for tail call optimization (at compilation time, due to Java's lack of support of tail call optimizations), data structures with fast traversal to any element that maximize sharing when a modified version is created, and efficient handling of lazy structures, among other mechanisms for providing efficiency. As the result, Clojure is as fast as Java on its underlying platform (the JVM), and much more efficient \stephencomment{I think we should specify that this is programmer efficiency rather than runtime efficiency} for concurrent execution due to immutability of data structures and significantly reduced need for locking and synchronization. 

Because of its convenience, efficiency, and elegant model \stephencomment{I'm not quite sure what you mean by model. Is this something that will be familiar to the audience?} Clojure is rapidly gaining popularity in software development community. \elenacomment{data goes here; perhaps reference some papers, perhaps the bioinformatics paper? Searching on "clojure" in ACM digital library gives some useful stuff.}

\elenacomment{Perhaps combine some sections, make them subsections.}

\elenacomment{A bit about assumed setup of CS curriculum}


\section{Benefits of teaching Clojure as the first language}

Benefits of teaching the functional programming paradigm in the first programming class for CS majors and minors are well-known \elenacomment{a citation?} \stephencomment{How about "The benefits of using a functional programming language in introductory Computer Science classes are well-known"?}. Functional languages focus on functions as programming units, provide abstraction, generalization, and modularity, and give a better understanding of recursion which is a basis of \stephencomment{many }important data structures and algorithms. Functional languages tend to have simpler, more uniform syntax that students master quickly. There are several successful introductory curricula that use functional languages, including \elenacomment{reference Racket, Haskell, ML?}\stephencomment{I think Racket definitely should be mentioned here. Not so sure about the other two. I know that Harvard uses a little ML, but Kent is the first school that I've heard of using Haskell for their intro classes and they are switching to Erlang next year.}

Developing a similar undergraduate curriculum based on Clojure would provide additional benefits \stephencomment{May be prudent to mention HTDP explicitly here.}. The immediate practical benefit of Clojure is that it fully integrates with Java since both compile to Java bytecode: Java code can be called from Clojure, and Clojure code can be called from Java. It is important to keep in mind that Clojure integrates with Java without losing efficiency, and Clojure itself is as efficient as Java and does not impede Java optimizations. Related to CS curriculum\stephencomment{??}, this allows seamless integration of Clojure into projects developed in Java or labs that use pre-written Java code. This gives students a choice of languages and paradigms that can even be made by a student or a group individually, without need for uniformity with the rest of the class or the rest of the project.\stephencomment{I think this paragraph needs to clarify what Java interop accomplishes for intro students. I'm not seeing how this would be successfully incorporated into 1301 from what you say here.}

A related benefit is Clojure's suitability for concurrency. Clojure provides mechanisms for multithreading that do not require explicit thread synchronization, locking objects, or adjustments to the number of processors. While Clojure concurrency cannot be fully covered in an introductory course, background in Clojure makes it easy for students to learn this material in a later course or, if needs to be, independently for a project or an internship. The key concepts, such as immutable persistent data structures, would be natural to students \stephencomment{"The students would already be familiar with the key concepts, such as immutable persistent data structures."}. \elenacomment{work in this citation: ~\cite{Brown:2010}}

Clojure is a language that was developed for real-life software development \stephencomment{"developed for use in industry" or "developed for industrial software development"}. It combines a rich set of features (including a variety of mechanisms for concurrency) with\stephencomment{ an} elegant uniform underlying model based on abstraction. Clojure ``collection\stephencomment{s}'' (i.e. data structures) include lists, vectors, sets, and hashmaps. However, all of them can be worked with as sequences \stephencomment{"All of these collections can be worked with as sequences..."} (more on that in section~\ref{sec:approaches}). While it would be impossible (and unnecessary) to present all of Clojure features in an undergraduate course, understanding the underlying abstractions and concepts makes it easy\stephencomment{ier} for students to build upon what they learn in the class\stephencomment{End sentence here} and learn on their own. The underlying abstractions also teach students about a good language design and problem solving that focuses on the essence of the problem and not on specifics of a given structure. 

Clojure has a well-developed community with online community-maintained documentation and examples, multiple blogs, several Google groups and an IRC channel, numerous open-source projects, a large number of meetups in many cities, and several excellent quality books (although not at a beginner programmer level). All these resources would enable students to continue their Clojure development past the introductory course. 


%\todo{Benefits of teaching Clojure to undergrads: provides all the benefits of teaching functional first, integrates with Java,  is used in industry and becoming quite popular (availability of examples), is done right, is a great language to program for oneself, introduces parallel computation}

\section{Technical challenges of teaching Clojure as the first language}
The key technical (as opposed to conceptual) challenges in teaching Clojure as the first programming language stem from the fact that it was not designed as a language for beginners. Clojure currently does not have a beginner-friendly development environment. Another significant problem is that Clojure error messages come directly from the Java implementation and mention Java types and other notions (such as null pointer exceptions) that do not appear directly in Clojure (Clojure is implicitly typed) and are not understandable to beginners. There are a few common functions with names that may be misleading to new students. Below we describe our work in progress to address these issues.\stephencomment{Watch the positioning of the tables. For me they are currently appearing in the middle of the preceding paragraph which is a little confusing.}

\subsection{Error messages}\label{subsec:errors}
Clojure error messages are Java exceptions and tend to mention Java types (some native to Java and some coming from Clojure\stephencomment{'s} implementation in Java) that are unclear to beginners, especially because Clojure is dynamically typed, and as a beginner you never have to specify any types explicitly. Types used in Clojure implementation form a rich Java hierarchy (for instance, numerous types implement an interface that represents a Clojure sequence type) \stephencomment{awk}. These details do not matter to students, but would get in the way of their learning experience. There are other cases when an error message does not make sense to new students, such as {\tt NullPointerException}. 

\begin{table}
\begin{tabular}{|c|c|}
\hline
Original type & Beginner-friendly type \\
\hline
java.lang.Number & a number \\
java.lang.Integer & a number \\
java.lang.Double  & a number \\
java.lang.Float & a number \\
java.lang.String & a string \\
java.lang.Character & a symbol \\
clojure.lang.Symbol  & a symbol \\
clojure.lang.ISeq & a sequence \\
\hline
\end{tabular}
\caption{Sample type conversion}\label{table:types}
\end{table}

 \begin{table}
\begin{tabular}{|c|c|c|}
\hline
Exception type & Original message & Beginner-friendly message \\
\hline 
{\tt ClassCastException} & $X$ cannot be cast to $Y$ & {\parbox{5cm}{Attempted to use $X'$, \\ 
but $Y'$ was expected.}} \\[0.3cm]
\hline
{\tt IllegalArgumentException} & 
Don't know how to create $X$ from:  $Y$ & 
{\parbox{5cm}{Don't know how to \\ create  $X'$ from $Y'$}} \\[0.3cm]
\hline
{\tt IndexOutOfBoundsException} & $n$ & {\parbox{5cm}{An index in a sequence \\ 
is out of bounds. The index is: $n$}} \\[0.3cm]
\hline
{\tt NullPointerException} & -- &  {\parbox{5cm}{An attempt to access a 
\\ non-existing object
\\ (NullPointerException)}} \\[0.3cm]
\hline
\end{tabular}
\caption{Sample message wording conversion. $X,Y$ are the original types, $X',Y'$ are the corresponding beginner-friendly types. }\label{table:messages}
\end{table}

The run-time environment that we are developing \elenacomment{mention earlier that we are developing an environment} intercepts Clojure errors by providing a {\tt try/catch} block around students' code and reformatting the error message. 
As an example, consider the following error message for {\tt (cons 2 3)}, i.e. at an attempt to {\tt cons} an element onto something that is not a sequence and cannot be converted to one:

{\tt IllegalArgumentException Don't know how to create ISeq from: java.lang.Long}

While the wording of the message is reasonably clear, the types used in it would not be understandable to beginner programmers at all. {\tt ISeq} is an interface that represents a Clojure sequence, but beginner students are not familiar with interfaces. Numbers in Clojure can be represented as a variety of types, and it is quite common for them to be represented as the {\tt  java.lang.Long} type. The exception type itself also is not useful to beginners for the most part. 

The error can be made clearer for beginners if we replace type names by those that make sense to beginners and remove the exception type:

{\tt Error: Don't know how to create a sequence from a number}. 

Table~\ref{table:types} shows more examples of type conversion. If no type match can be found, either by a lookup or by checking interfaces that a type implements (e.g. a variety of types that represent functions that all implement {\tt IFn} interface), then we would display the type as an ``unrecognized type'' followed by the actual type. However, as we expand our type dictionary and continue testing, these cases occur less and less frequently. 

There are other error messages that require conversion to more beginner-friendly wording, see table~\ref{table:messages} for more examples. 

Another issue that can be solved by catching and reformatting Clojure error messages is its stack trace. A complete stack trace of an error message often can contain over a hundred of Clojure and Java function calls. The way we approach this issue is by filtering out everything in the stack that is not a part of the student's project (such a project may include some of our own functions added for simplicity). This allows students to see the part of the stack trace that directly relates to their code, and nothing else. 

%\todo{an example of error messages before and after}

The error message filtering has worked well in tests and gives messages that make sense to beginners (our testing group includes two sophomores with no prior experience with Clojure \elenacomment{Might move it earlier}). Among issues that we still need to address, however, are compilation errors which cannot be caught at run time and some errors that show up after {\tt main} finishes due to lazy evaluation. A way to approach this issue would be to use our own run system instead of the one provided with the Clojure project manager (see section~\ref{subsec:envt} for details). 

%\elenacomment{issues: compilation error messages; laziness and project setup}

\subsection{Development environment}\label{subsec:envt}
Even though new students start off by simply writing a code in a file, their code would typically be a part of a project \stephencomment{I feel like this could be worded better. Maybe instead of "project" we say something like "their code would be run within our custom environment."}. This is due to the exception-catching facilities and some predefined Clojure functions that we need to supply for students to use in their own code. There are also some libraries (such as a turtle graphics library~\cite{turtle} and a Clojure wrapper around Java swing, called seesaw~\cite{graphics}) that students will be using. We would like to be able to run students' code as a complete program (designated in a project setup) as well as in \stephencomment{a} REPL \elenacomment{make sure to clarify what that is earlier} for interactive testing. Our plan is to provide a template project that contains all of the necessary libraries and project settings. 

Clojure projects are managed via a command-line tool called leiningen~\cite{lein}. Leiningen downloads necessary libraries, controls compilation, and allows one to run either a function of the project designated as ``main'' or start REPL with all of the project's code loaded. 

In order to serve as a truly fitting Clojure development environment for beginner programmers, an IDE must have the following characteristics: 
\begin{itemize}
\item Provide at least basic syntax highlighting and formatting. 
\item Provide at least the basics of Clojure project management. 
\item Report errors in a reasonable way, with line numbers. 
\item Be convenient and easy to understand. 
\item Be reliable and bug-free.
\end{itemize}
Unfortunately, there is not a perfect IDE for Clojure. Both text editor {\tt emacs} and a plugin for a common Java IDE {\tt Eclipse} are too complicated for beginners \stephencomment{Text editors {\tt emacs} and the plugin for the common Java IDE Eclipse are too complicated for beginners.}. There are several test \stephencomment{Remove "test"} editors developed specifically for Clojure, but they are still in development stages and do not function well. Our current decision is to go with the text editor {\tt jEdit} \elenacomment{add citation} which provides Clojure syntax highlighting, and manage projects on the command line via leiningen commands.  We are working on incorporating calls to leiningen  commands into \stephencomment{a} jEdit menu. 

Our work-in-progress is to incorporate leiningen menu into jEdit by writing a plugin \stephencomment{"We are currently working on creating a leinigen plugin for jEdit"}, and also to enable beginner-friendly error reporting not only when running {\tt main}, but also for compilation errors and those generated by REPL. Currently we still get un-converted error messages in these two cases. 

\subsection{Other language modifications}\label{subsec:other}
There are a few functions that we would like to provide as an alternative to complicated or misleading (for beginners) functions in Clojure. For instance, {\tt contains?} function returns {\tt true} if a key is present in a data structure, and not the element. This means that it would return {\tt true} if passed any vector of with a length of at least $2$ and the number $1$, regardless of the actual elements of the vector, since indices in a vector are considered keys. Providing a function with a more intuitive name, such as {\tt contains-value?}, would solve this issue. There are other similar examples of functions that may confuse beginners, and we are providing alternatives with more precise names. 

%\todo{Error messages, development environment, lack of examples for beginners, some confusing names since they are a part of a full-scale language.}

\section{Approaches to teaching Clojure to beginners}\label{sec:approaches}
Clojure provides a rich set of immutable collections (lists, vectors, sets, hash-maps). Each collection has a specific implementation in Clojure. For instance, lists are singly-linked lists, similar in a concept to Common Lisp lists that are a chain of cons-cells. Creating a new list from an existing one can be done in a constant time when an element is added or removed from the beginning since it takes advantage of sharing the rest of the elements after the one we are adding or removing. The new list is just a reference to its first element. However, adding an element at the end takes a linear time since the entire list needs to be copied. 

Vectors are a highly efficient data structure for both insertion and deletion at any position in a close to constant time: $log_{32} N$, where $N$ is the number of elements in the vector. 

\todo{Clojure concepts: sequence abstraction vs concrete collections, laziness; providing examples for beginners + knowledge of complete language to understand other examples.}

\section{Conclusions}

\section{Bibliography}

\bibliographystyle{eptcs}
\bibliography{overview}
\end{document}



Sample stuff from example for now.

%We request that you use
%\href{http://www.cse.unsw.edu.au/~rvg/EPTCS/eptcs.bst}
%{\tt $\backslash$bibliographystyle$\{$eptcs$\}$}
%\cite{bibliographystylewebpage}. Compared to the original {\LaTeX}
%{\tt $\backslash$biblio\-graphystyle$\{$plain$\}$},
%it ignores the field {\tt month}, and uses the extra
%bibtex fields {\tt eid}, {\tt doi}, {\tt ee} and {\tt url}.
%The first is for electronic identifiers (typically the number $n$
%indicating the $n^{\rm th}$ paper in an issue) of papers in electronic
%journals that do not use page numbers. The other three are to refer,
%with life links, to electronic incarnations of the paper.
%
%Almost all publishers use digital object identifiers (DOIs) as a
%persistent way to locate electronic publications. Prefixing the DOI of
%any paper with {\tt http://dx.doi.org/} yields a URI that resolves to the
%current location (URL) of the response page\footnote{Nowadays, papers
%  that are published electronically tend
%  to have a \emph{response page} that lists the title, authors and
%  abstract of the paper, and links to the actual manifestations of
%  the paper (e.g.\ as {\tt dvi}- or {\tt pdf}-file). Sometimes
%  publishers charge money to access the paper itself, but the response
%  page is always freely available.}
%of that paper. When the location of the response page changes (for
%instance through a merge of publishers), the DOI of the paper remains
%the same and (through an update by the publisher) the corresponding
%URI will then resolve to the new location. For that reason a reference
%ought to contain the DOI of a paper, with a life link to corresponding
%URI, rather than a direct reference or link to the current URL of
%publisher's response page. This is the r\^ole of the bibtex field {\tt doi}.
%DOIs of papers can often be found through
%\url{http://www.crossref.org/guestquery};\footnote{For papers that will appear
%  in EPTCS and use \href{http://www.cse.unsw.edu.au/~rvg/EPTCS/eptcs.bst}
%  {\tt $\backslash$bibliographystyle$\{$eptcs$\}$} there is no need to
%  find DOIs on this website, as EPTCS will look them up for you
%  automatically upon submission of a first version of your paper;
%  these DOIs can then be incorporated in the final version, together
%  with the remaining DOIs that need to found at DBLP or publisher's webpages.}
%the second method {\it Search on article title}, only using the {\bf
%surname} of the first-listed author, works best.  
%Other places to find DOIs are DBLP and the response pages for cited
%papers (maintained by their publishers).
%{\bf EPTCS requires the inclusion of a DOI in each cited paper, when available.}
%
%Often an official publication is only available against payment, but
%as a courtesy to readers that do not wish to pay, the authors also
%make the paper available free of charge at a repository such as
%\url{arXiv.org}. In such a case it is recommended to also refer and
%link to the URL of the response page of the paper in such a
%repository.  This can be done using the bibtex fields {\tt ee} or {\tt
%url}, which are treated as synonyms.  These fields should not be used
%to duplicate information that is already provided through the DOI of
%the paper.
%You can find archival-quality URL's for most recently published papers
%in DBLP---they are in the bibtex-field {\tt ee}. In fact, it is often
%useful to check your references against DBLP records anyway, or just find
%them there in the first place.
%
%When using {\LaTeX} rather than {\tt pdflatex} to typeset your paper, by
%default no linebreaking within long URLs is allowed. This leads often
%to very ugly output, that moreover is different from the output
%generated when using {\tt pdflatex}. This problem is repaired when
%invoking \href{http://www.cse.unsw.edu.au/~rvg/EPTCS/breakurl.sty}
%{\tt $\backslash$usepackage$\{$breakurl$\}$}: it allows linebreaking
%within links and yield the same output as obtained by default with
%{\tt pdflatex}. 
%When invoking {\tt pdflatex}, the package {\tt breakurl} is ignored.
%
%%\nocite{*}
%%\bibliographystyle{eptcs}
%%\bibliography{generic}
%\end{document}
