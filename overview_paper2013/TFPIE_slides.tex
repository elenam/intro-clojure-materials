\documentclass{beamer}
\usepackage{beamerthemeshadow}
\usepackage{color}
\usepackage[all]{xy}



\mode<presentation>
{
  \usetheme{CambridgeUS} %%% Change later
 \usecolortheme{beaver}


  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}
\setbeamertemplate{footline}[page number]{}


\begin{document}
\title{Steps towards teaching the Clojure programming language in an introductory CS  class}
\author{Elena Machkasova, Stephen J Adams, Joe Einertson}
\institute[UMM] % (optional, but mostly needed)
{
 % \inst{1}%
  University of Minnesota, Morris
}
\date[May 13, 2013]  
{Trends in Functional Programming in Education (TFPIE) 2013.}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}

  \frametitle{Outline}
\tableofcontents
\end{frame}

\section{Overview of Clojure}

\begin{frame}
\frametitle{What is Clojure?}
\begin{itemize}
\item Clojure is a LISP.
\item Developed by Rich Hickey, released in 2007, rapidly gaining popularity. 
\item Supports concurrency.
\item Provides multiple immutable persistent data structures (lists, vectors, hash maps, sets, etc.).
\item Runs on the JVM, fully integrated with Java. 
\item Provides REPL (Read Eval Print Loop).
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Why the popularity?}
\begin{itemize}
\item Elegant.
\item Efficient (fast bytecode, tail recursion optimization).
\item Convenient and safe efficient multi-threading. 
\item Access to Java (e.g. Clojure seesaw library which uses Java swing). 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Why Clojure in intro CS courses?}
\begin{itemize}
\item It's a real-life language done well. 
\item Introduces multiple data structures; abstraction vs implementation. 
\item Can be used in later courses  (concurrency, interoperability with Java, purely functional data structures). 
\item Has a friendly community (online resources, google groups, open source projects, meetups) - easy to continue on your own. 
\item Rapidly increasing demand in industry. 
\end{itemize}
\end{frame}

%\section{Clojure at UMM}
\begin{frame}
\frametitle{Clojure at UMM.}
\begin{itemize}
\item UMM (University of Minnesota, Morris) is an undergrad-only liberal arts campus of UMN, has a small, very active CS department. 
\item Included Clojure in upper-division courses (concurrency, functional programming). 
\item Would like to teach it in intro classes (majors, minors, interested individuals).
\item Introductory course focuses on problem solving and key concepts, e.g. abstraction, recursion.
\item Current project: development environment for beginners; developing approaches for teaching Clojure to beginners. 
\end{itemize}
\end{frame}

\section{Technical challenges of teaching Clojure as the first language}

\begin{frame}
\frametitle{Development environment: text editor.}
Currently there are very few options for a text editor for beginner programmers. 

What doesn't work:
\begin{itemize}
\item Emacs, vim (too complicated for beginners).
\item Eclipse plugin Counterclockwise (too large).
\item Clojure-specific text editors: Clooj, Catnip (too unstable). 
\end{itemize}
What we would like eventually:
\begin{itemize}
\item Light Table: a text editor based on functions, not files; instant evaluation, etc. Still in development. 
\end{itemize}
What we are using:
\begin{itemize}
\item jEdit with LISP/Clojure plugins. 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Development environment: project setup.}
Clojure projects are managed by a tool {\tt leiningen}. We need to include beginner-friendly error handling and beginner-friendly functions; intercept code typed into REPL. 

We are developing {\tt leiningen} plugins for creating and running student projects (work in progress). 
\end{frame}

\begin{frame}
\frametitle{Error handling.}

\end{frame}

\section{Approaches to teaching Clojure to beginners}

\begin{frame}
\frametitle{Collections vs sequence abstraction}
Clojure collections: lists, vectors, hash maps, sets, etc. Collections:
\begin{itemize}
\item ...are stored in a way that optimizes their intended use. 
\begin{itemize}
\item lists have constant access time to the beginning and linear to the end. 
\item vectors are shallow trees, provide logarithmic access to any position.
\end{itemize}
\item ...have a few functions specialized to a collection type, e.g. {\tt conj} that returns a collection of the same type with a new element added. 
\begin{itemize}
\item lists: {\tt (conj '(2 3 1) 4)} results in a list {\tt (4 2 3 1)}.
\item vectors: {\tt (conj [2 3 1] 4)} results in a vector {\tt [2 3 1 4]}.
\end{itemize}
\end{itemize}
The difference in behavior is likely to be confusing to beginners. 
\end{frame}

\begin{frame}
\frametitle{Collections vs sequence abstraction (cont)}
Sequences are an abstraction for a number of elements (possibly infinite) in a specific order. 
\begin{itemize}
\item Most Clojure functions work on sequences and return sequences (e.g. {\tt map}). 
\item It is easier for beginners to program in a collection-independent (i.e. abstract) way.
\item We provide several functions that work in a collection-independent way. They return sequences (look like lists):
\begin{itemize}
\item {\tt (add-first '(2 3 1) 4)} results in a sequence {\tt (4 2 3 1)}.
\item {\tt (add-first [2 3 1] 4)} results in a sequence {\tt (4 2 3 1)}.
\item {\tt (add-last '(2 3 1) 4)} results in a sequence {\tt (2 3 1 4)}.
\item {\tt (add-last [2 3 1] 4)} results in a sequence {\tt (2 3 1 4)}.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Collections vs sequence abstraction (example)}
Consider reversing a sequence using {\tt reduce} (same as {\tt fold}). Note: {\tt defn} = define function, {\tt fn} = anonymous function (lambda), 
%%{\tiny
\begin{verbatim}
;; works because conj adds to the beginning of a list
(defn my-reverse [coll]
    (reduce (fn [c x] (conj c x)) '() coll)) 

;; doesn't work because conj adds at the end of a vector
(defn my-reverse [coll]
    (reduce (fn [c x] (conj c x)) [] coll)) 

;; abstract approach (works with a list or a vector)
(defn my-reverse [coll]
    (reduce (fn [c x] (add-first x c)) () coll)) 
\end{verbatim}
%%} %%% end tiny
\end{frame}

\begin{frame}
\frametitle{Abstraction-based teaching approach}
\begin{itemize}
\item Students will be introduced to both collection-specific and collection-independent functions. 
\item Understanding the difference between the specifics of collections and the sequence abstraction is a learning experience that will carry on to data structures and software development. 
\end{itemize}
\end{frame}

\end{document}

