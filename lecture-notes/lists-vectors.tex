\section{Introduction to Lists and Vectors}\label{sec:list-vectors}
Clojure provides many ways of storing data. 
\elenacomment{Add a transition.} 

 \fut{Collections} are containers for storing data. There many types of collections, each suited to store data for a specific set of purposes. Every type of collections has a particular implementation in computer memory: its elements are stored in a specific way. Some collections allow faster access to data, some allow better ways of indexing it, some store data in a specific order, and some in a set-like fashion in which the order of elements does not matter. 

If you read Clojure documentation or examples, you will notice that people frequently mention \fut{sequences}. Sometimes the terms ``collection'' and ``sequence"' seem to be used interchangeably. While there are many situations in which you can refer to the same data container as a collection or a sequence, they are not the same. A \fut{sequence} is not any concrete collection, but an abstraction. It refers to the ability to get elements from a collection (as well as from other sources, such as user input) in a \fut{sequential} manner: a fancy word for getting elements \fut{one at a time}. It does not matter how elements are stored internally: if you get the same elements in the same order from two containers, they are equal as sequences.

We will discuss collections and sequences more in the future, but for now remember that while both collections and sequences are used to describe data containers, \takeaway{collections refer to a concrete way of storing data in memory} and \takeaway{sequences are an abstraction for accessing elements in a sequential manner}. 

The two types of collections that we introduce at this point are \fut{lists} and \fut{vectors}. We explain some of the differences between the two and reasons for these differences. 

Both lists and vectors allow one to store data (of any type) in some order. Historically, lists have been the main data storage in the Lisp family of programming languages. They have a straightforward internal implementation. Vectors are unique to Clojure and are designed to be more efficient. Some details of the implementation of lists and vectors will be discussed later \elenacomment{Reference + more reading?}. 

Lists store their items in way that acts like a stack on plates: new items are added at ``the top'', and one needs to take an item, they take it from ``the top''.  Of course, there is really no top in the machine representation of memory, but it is a convenient analogy.  This way of accessing elements in called \fut{last-in-first-out} and is abbreviated as \fut{LIFO}. Lists historically have been the main data structure in the Lisp family of languages. 

Vectors store their items similarly to a queue in a cafeteria: items are added at ``the end'' and removed from ''the beginning''. Once again, ``the end'' and removed from ''the beginning'' are just a convenient analogy, and do not correspond to the internal implementation. This way of accessing elements in often called \fut{first-in-first-out} and is abbreviated as \fut{FIFO}. 

\subsection{The very basics of lists}\label{subsec:lists}
Examples below show how to create a list and to work with it. Note that the single quotation mark in front of the list is needed: without it the parentheses would be interpreted as a function application. However, when the interpreter evaluates the list, the quotation mark is not printed. One can define an empty list, i.e. a list with no elements at all, by not putting any elements in the list: \clocode{'()}.
\begin{framed}
\begin{verbatim}
intro.core=> '(1 2 3)  ; creating a list
(1 2 3)
intro.core=> '(1 true 8.5) ; we can have anything in a list
(1 true 8.5)
intro.core=> (def mylist '(1 2 3)) ;saving a list in a variable
#'intro.core/mylist
intro.core=> mylist
(1 2 3)
intro.core=> (def emptylist '()) ; create an empty list
#'intro.core/emptylist
intro.core=> emptylist
()
\end{verbatim}
\end{framed}
A subtle point is that in Clojure you don't need to put the quotation mark in front of an empty list: \clocode{(def emptylist ())} works just fine. I will, for the most part, stick to using the quotation mark for uniformity, but feel free to skip it in your code if you prefer. Not, however, that forgetting the quotation mark for a non-empty list is an error: \clocode{ (def trylist (1 2 3))} results in the error \cloerr{Attempted to use a number, but a function was expected}. This is because \clocode{(1 2 3)} is interpreted as \clocode{1} applied to the arguments \clocode{2 3}, but \clocode{1} is a number, not a function. 

There are many functions that operate on lists (most of them can also operate on other collections). The most fundamental ones are \clocode{first} that returns the first element in a list and \clocode{rest} that returns the list of all elements of the list except the first one. The rest of a one element list is an empty list. Continuing our example: 
\begin{framed}
\begin{verbatim}
intro.core=> (first mylist)
1
intro.core=> (rest mylist)
(2 3)
intro.core=> mylist
(1 2 3)
intro.core=> (rest '(1)) ; 
()
\end{verbatim}
\end{framed}
Note the important difference: \takeaway{\clocode{first} returns an element, and \clocode{rest} returns a list.} 

Often you need to check if a list (or any other collection) is empty. A collection is \fut{empty} if it does not have any elements. There are several ways to check if a list empty, but for now we cover just one, the function \clocode{empty?} (recall the convention that names of functions returning a boolean end with a question mark). The function returns \clocode{true} if the list is empty and \clocode{false} otherwise.
\begin{framed}
\begin{verbatim}
intro.core=> (empty? '(5))
false
intro.core=> (empty? '())
true
intro.core=> (empty? (rest '(5)))
true
\end{verbatim}
\end{framed}

\subsection{The very basics of vectors}\label{subsec:vectors}
As we mentioned earlier, vectors are Clojure-specific collection with a faster implementation than lists. They are similar to lists in many ways, so the examples below may look like lists, just with a different notation, although there are a few differences that we will discuss. Section~\ref{subsec:conj-lists-vectors} focuses more on the differences between lists and vectors. 

When creating a vector of particular elements, use square brackets (without a quotation). An empty vector is written as an empty set of square brackets.
\begin{framed}
\begin{verbatim}
intro.core=> [1 2 3] ; creating a vector
[1 2 3]
intro.core=>  ; vectors can have any type of elements: 
intro.core=> [true 6.7 "banana" false]
[true 6.7 "banana" false]
intro.core=> [] ; an empty vector
[]
intro.core=> (def myvector [5 3 4]) ; store vector in a variable 
#'intro.core/myvector
intro.core=> myvector
[5 3 4]
\end{verbatim}
\end{framed}
The same functions  \clocode{first}, \clocode{rest}, and \clocode{empty?} work on vectors:

\begin{framed}
\begin{verbatim}
intro.core=> (first myvector)
5
intro.core=> (rest myvector) ; returns a sequence!
(3 4)
intro.core=> (empty? myvector)
false
intro.core=> (empty? [])
true
\end{verbatim}
\end{framed}
The results of   \clocode{first} and  \clocode{empty?}  are as expected. Observe, however, that even though \clocode{rest} returns all but the first elements of the vector (just like for lists), it returns it as something that looks like a list, not a vector: \clocode{(3 4)}. That is because  \clocode{rest}, just like most other functions on collections, returns the result as a sequence, not any specific collection. In fact, \clocode{rest} for lists also returns some collection, and not necessarily a list, but sequences are shown just like lists, so there is no way at this point to observe the difference. 

This approach allows for a more uniform treatment of collections: since most functions on collections take and return sequences rather than specific collection types (such as lists and vectors), it's much easier to combine them following sequence abstraction rather than being concerned with details of a specific collection type. Sections~\ref{subsec:conj-lists-vectors} and~\ref{subsec:sequences} discuss this approach further. 

To summarize, \takeaway{vectors are similar to lists in how they are created and worked with}, although they have a slightly different syntax.  \takeaway{The function \clocode{rest} on both lists and vectors returns a sequence, not any particular collection type.}


\subsection{\clocode{nil}: representing ``nothing" in Clojure}\label{subsec:nil}
What happens if we call \clocode{first} or \clocode{rest} on an empty list or a vector?  Let us try it in REPL:
\begin{framed}
\begin{verbatim}
intro.core=> (rest '())
()
intro.core=> (rest [])
()
intro.core=> (empty? (rest '()))
true
intro.core=> (empty? (rest []))
true
intro.core=> (first '())
nil
intro.core=> (first [])
nil
\end{verbatim}
\end{framed}
The first four lines of code show that \clocode{rest} of an empty collection (a list or a vector) is an empty sequence \clocode{()}. This makes sense because there are no elements that belong to this sequence. Taking \clocode{first} of an empty sequence is more interesting: it is supposed to return the first element, but there is no element to return. 

One may think that an attempt to take the first element would result in an error (which is what happens in some other languages), but that's not what happens. Instead \clocode{first} of an empty sequence returns a special value \clocode{nil}. \clocode{nil} stands for \fut{nothing}. It is often returned from functions that failed to find an elements with desired properties in a sequence. In this case \clocode{first} failed to find the first element, thus \clocode{nil} is a proper thing to return. 

Since we will be encountering \clocode{nil} quite often, it is helpful to study it a bit more. We will also look into the corresponding function \clocode{nil?} that checks whether a given value is nil. Below are some tests that we ran on  \clocode{nil}:
\begin{framed}
\begin{verbatim}
intro.core=> (empty? nil)
true
intro.core=> (nil? '())
false
\end{verbatim}
\end{framed}
We notice that while \clocode{nil} is considered to be empty, an empty list (or any other empty sequence, as you can easily check) is not nil. One may think of  \clocode{nil} as ``emptier than empty''. 

To summarize: \takeaway{\clocode{nil} is a special value in Clojure that means ``nothing at all''. It is often returned from functions that cannot find an element with certain properties in a sequence, such as the first element in an empty sequence. While \clocode{nil} is considered an empty sequence, an empty sequence is not considered nil.}

\subsection{Creating lists and vectors out of existing ones}\label{subsec:conj-lists-vectors}
It is quite common to create collections from existing ones by adding elements to them. Since Clojure is a functional language, its data storage is  immutable which means that every time you add an element to a collection you are actually creating a new one, not modifying the existing one. \elenacomment{add a back reference to discussion of immutability} It seems very inefficient, but keep in mind that collections are designed in such a way that, even though a new collection is created with every added (or removed) element, common parts of the old and the new collection are reused.  \elenacomment{add a forward reference to the corresponding discussion - need some diagrams!}

There are two ways to add an element to a collection: \fut{collection-specific} and \fut{collection-independent}. In a collection-specific approach you create a collection of exactly the same type as the one you are adding to. In a collection-independent approach your result is some type of  sequence, and since all sequences act the same, it doesn't matter how the resulting sequence is implemented internally. Both approaches have their benefits which we discuss after we introduce both. 

\subsubsection{Collection-specific addition of elements to lists and vectors. }\label{subsubsec:conj}

\elenacomment{conj}

\subsubsection{Collection-independent addition of elements to lists and vectors. }\label{subsubsec:add-first-last}

\elenacomment{add-first, add-last}

\subsubsection{Combining two lists or vectors}\label{subsubsec:into-concat}

\elenacomment{into, concat}

\subsection{Working with sequences}\label{subsec:sequences}

Sequences generally act like lists. 

\elenacomment{introduce \clocode{seq?}}

\subsection{In-depth: implementation of lists and vectors}\label{subsec:implement}

\subsection{Section resources:}
\begin{itemize}
\item \url{http://bpeirce.me/clojure-sequence-implementations.html}
\end{itemize}

