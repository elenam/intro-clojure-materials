\section{Introduction to Lists and Vectors}\label{sec:list-vectors}
Clojure provides many ways of storing data. 
\elenacomment{Add a transition.} 

 \fut{Collections} are containers for storing data. There many types of collections, each suited to store data for a specific set of purposes. Every type of collections has a particular implementation in computer memory: its elements are stored in a specific way. Some collections allow faster access to data, some allow better ways of indexing it, some store data in a specific order, and some in a set-like fashion in which the order of elements does not matter. 

If you read Clojure documentation or examples, you will notice that people frequently mention \fut{sequences}. Sometimes the terms ``collection'' and ``sequence"' seem to be used interchangeably. While there are many situations in which you can refer to the same data container as a collection or a sequence, they are not the same. A \fut{sequence} is not any concrete collection, but an abstraction. It refers to the ability to get elements from a collection (as well as from other sources, such as user input) in a \fut{sequential} manner: a fancy word for getting elements \fut{one at a time}. It does not matter how elements are stored internally: if you get the same elements in the same order from two containers, they are equal as sequences.

We will discuss collections and sequences more in the future, but for now remember that while both collections and sequences are used to describe data containers, \takeaway{collections refer to a concrete way of storing data in memory} and \takeaway{sequences are an abstraction for accessing elements in a sequential manner}. 

The two types of collections that we introduce at this point are \fut{lists} and \fut{vectors}. We explain some of the differences between the two and reasons for these differences. 

Both lists and vectors allow one to store data (of any type) in some order. Historically, lists have been the main data storage in the Lisp family of programming languages. They have a straightforward internal implementation. Vectors are unique to Clojure and are designed to be more efficient. Some details of the implementation of lists and vectors will be discussed later \elenacomment{Reference + more reading?}. 

Lists store their items in way that acts like a stack on plates: new items are added at ``the top'', and one needs to take an item, they take it from ``the top''.  Of course, there is really no top in the machine representation of memory, but it is a convenient analogy.  This way of accessing elements in called \fut{last-in-first-out} and is abbreviated as \fut{LIFO}. Lists historically have been the main data structure in the Lisp family of languages. 

Vectors store their items similarly to a queue in a cafeteria: items are added at ``the end'' and removed from ''the beginning''. Once again, ``the end'' and removed from ''the beginning'' are just a convenient analogy, and do not correspond to the internal implementation. This way of accessing elements in often called \fut{first-in-first-out} and is abbreviated as \fut{FIFO}. 

\subsection{Creating lists and working with lists}\label{subsec:lists}
Examples below show how to create a list. Note that the single quotation mark in front of the list is needed: without it the parentheses would be interpreted as a function application. However, when the interpreter evaluates the list, the quotation mark is not printed. One can define an empty list, i.e. a list with no elements at all, by not putting any elements in the list: \clocode{'()}.
\begin{framed}
\begin{verbatim}
intro.core=> '(1 2 3)  ; creating a list
(1 2 3)
intro.core=> '(1 true 8.5) ; we can have anything in a list
(1 true 8.5)
intro.core=> (def mylist '(1 2 3)) ;saving a list in a variable
#'intro.core/mylist
intro.core=> mylist
(1 2 3)
intro.core=> (def emptylist '()) ; create an empty list
#'intro.core/emptylist
intro.core=> emptylist
()
\end{verbatim}
\end{framed}
There are many functions that operate on lists (most of them can also operate on other collections). The most fundamental ones are \clocode{first} that returns the first element in a list and \clocode{rest} that returns the list of all elements of the list except the first one. The rest of a one element list is an empty list. Continuing our example: 
\begin{framed}
\begin{verbatim}
intro.core=> (first mylist)
1
intro.core=> (rest mylist)
(2 3)
intro.core=> mylist
(1 2 3)
intro.core=> (rest '(1)) ; 
()
\end{verbatim}
\end{framed}
Note the important difference: \takeaway{\clocode{first} returns an element, and \clocode{rest} returns a list.}

Sequences generally act like lists. 


\subsection{Section resources:}
\begin{itemize}
\item \url{http://bpeirce.me/clojure-sequence-implementations.html}
\end{itemize}

